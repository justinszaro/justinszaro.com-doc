"use strict";(self.webpackChunkjustinszaro_com_docs=self.webpackChunkjustinszaro_com_docs||[]).push([[1163],{9597:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>r});const a=JSON.parse('{"id":"technologies/Javascript/Packages/MongooseJS/Mongoose Guides","title":"Mongoose Guides","description":"Documentation","source":"@site/docs/technologies/Javascript/Packages/MongooseJS/guides.md","sourceDirName":"technologies/Javascript/Packages/MongooseJS","slug":"/technologies/Javascript/Packages/MongooseJS/Mongoose Guides","permalink":"/docs/technologies/Javascript/Packages/MongooseJS/Mongoose Guides","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"javascript","permalink":"/docs/tags/javascript"},{"inline":true,"label":"mongoose","permalink":"/docs/tags/mongoose"}],"version":"current","frontMatter":{"id":"Mongoose Guides","tags":["javascript","mongoose"]},"sidebar":"technologies","previous":{"title":"Why Cypress","permalink":"/docs/technologies/Javascript/Packages/Cypress/Getting Started with Cypress"},"next":{"title":"Mongoose","permalink":"/docs/technologies/Javascript/Packages/MongooseJS/Mongoose Quick Start"}}');var i=s(4848),o=s(8453);const t={id:"Mongoose Guides",tags:["javascript","mongoose"]},l="Mongoose Guides",c={},r=[{value:"Schemas",id:"schemas",level:2},{value:"Defining your Model",id:"defining-your-model",level:3},{value:"Creating a Model",id:"creating-a-model",level:3},{value:"Ids",id:"ids",level:3},{value:"Instance Methods",id:"instance-methods",level:3},{value:"Statics",id:"statics",level:3},{value:"Query Helpers",id:"query-helpers",level:3},{value:"Indexes",id:"indexes",level:3},{value:"Virtuals",id:"virtuals",level:3},{value:"Aliases",id:"aliases",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"mongoose-guides",children:"Mongoose Guides"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://mongoosejs.com/docs/index.html",children:"Documentation"})}),"\n",(0,i.jsx)(n.h2,{id:"schemas",children:"Schemas"}),"\n",(0,i.jsx)(n.h3,{id:"defining-your-model",children:"Defining your Model"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Schema map json objects to a MongoDB collection that defines and shapes the documents within the collection:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import mongoose from 'mongoose';\nconst { Schema } = mongoose;\n\nconst blogSchema = new Schema({\n  title: String, // String is shorthand for {type: String}\n  author: String,\n  body: String,\n  comments: [{ body: String, date: Date }],\n  date: { type: Date, default: Date.now },\n  hidden: Boolean,\n  meta: {\n    votes: Number,\n    favs: Number\n  }\n});\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If a property only needs a type, it can be shorthanded like above."}),"\n",(0,i.jsxs)(n.li,{children:["Keys can also be included in nested objects like ",(0,i.jsx)(n.code,{children:"meta"}),".","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Mongoose only creates paths for nested objects, like ",(0,i.jsx)(n.code,{children:"meta.votes"})," and ",(0,i.jsx)(n.code,{children:"meta.faves"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["In this case, ",(0,i.jsx)(n.code,{children:"meta"})," can not have its own validation."]}),"\n",(0,i.jsx)(n.li,{children:"If validation is needed, a path can be made up the tree."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Permitted Schema Types:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"String"}),"\n",(0,i.jsx)(n.li,{children:"Number"}),"\n",(0,i.jsx)(n.li,{children:"Date"}),"\n",(0,i.jsx)(n.li,{children:"Buffer"}),"\n",(0,i.jsx)(n.li,{children:"Boolean"}),"\n",(0,i.jsx)(n.li,{children:"Mixed"}),"\n",(0,i.jsx)(n.li,{children:"ObjectId"}),"\n",(0,i.jsx)(n.li,{children:"Array"}),"\n",(0,i.jsx)(n.li,{children:"Decimal128"}),"\n",(0,i.jsx)(n.li,{children:"Map"}),"\n",(0,i.jsx)(n.li,{children:"UUID"}),"\n",(0,i.jsx)(n.li,{children:"Double"}),"\n",(0,i.jsx)(n.li,{children:"Int32"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"creating-a-model",children:"Creating a Model"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Schemas can be used to create Models."}),"\n",(0,i.jsx)(n.li,{children:"To create a model:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const Blog = mongoose.model('Blog', blogSchema);\n// ready to go!\n"})}),"\n",(0,i.jsx)(n.h3,{id:"ids",children:"Ids"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"By default, Mongoose adds an _id property to schemas."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const schema = new Schema();\n\nschema.path('_id'); // ObjectId { ... }\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["When a document is created with an object id, it has the type ",(0,i.jsx)(n.code,{children:"ObjectId"}),":"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const Model = mongoose.model('Test', schema);\n\nconst doc = new Model();\ndoc._id instanceof mongoose.Types.ObjectId; // true\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["You can overwrite the default id with your own _id.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Caution: MongoDB will not save an object without a top-level ID."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const schema = new Schema({\n  _id: Number // <-- overwrite Mongoose's default `_id`\n});\nconst Model = mongoose.model('Test', schema);\n\nconst doc = new Model();\nawait doc.save(); // Throws \"document must have an _id before saving\"\n\ndoc._id = 1;\nawait doc.save(); // works\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Mongoose also adds an ",(0,i.jsx)(n.code,{children:"_id"})," property to sub documents."]}),"\n",(0,i.jsxs)(n.li,{children:["Sub documents can have their ",(0,i.jsx)(n.code,{children:"_id"}),"s disabled and will still save properly."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const nestedSchema = new Schema(\n  { name: String },\n  { _id: false } // <-- disable `_id`\n);\nconst schema = new Schema({\n  subdoc: nestedSchema,\n  docArray: [nestedSchema]\n});\nconst Test = mongoose.model('Test', schema);\n\n// Neither `subdoc` nor `docArray.0` will have an `_id`\nawait Test.create({\n  subdoc: { name: 'test 1' },\n  docArray: [{ name: 'test 2' }]\n});\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"_id"})," can be disabled using the following:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const nestedSchema = new Schema({\n  _id: false, // <-- disable _id\n  name: String\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"instance-methods",children:"Instance Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Instances of models are called documents."}),"\n",(0,i.jsx)(n.li,{children:"Documents have numerous built in methods, you can also define your own!"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// define a schema\nconst animalSchema = new Schema({ name: String, type: String },\n  {\n  // Assign a function to the \"methods\" object of our animalSchema through schema options.\n  // By following this approach, there is no need to create a separate TS type to define the type of the instance functions.\n    methods: {\n      findSimilarTypes(cb) {\n        return mongoose.model('Animal').find({ type: this.type }, cb);\n      }\n    }\n  });\n\n// Or, assign a function to the \"methods\" object of our animalSchema\nanimalSchema.methods.findSimilarTypes = function(cb) {\n  return mongoose.model('Animal').find({ type: this.type }, cb);\n};\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This allows for all instances of ",(0,i.jsx)(n.code,{children:"animal"})," to have the ",(0,i.jsx)(n.code,{children:"findSimilarTypes"})," function."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const Animal = mongoose.model('Animal', animalSchema);\nconst dog = new Animal({ type: 'dog' });\n\ndog.findSimilarTypes((err, dogs) => {\n  console.log(dogs); // woof\n});\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Be cautious when overriding built in Mongoose methods. It can have unforeseen consequences!"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"statics",children:"Statics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Static functions can also be added to the model."}),"\n",(0,i.jsxs)(n.li,{children:["There are three different ways to add a Static function:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Add a function property to the second argument of the schema-constructor (",(0,i.jsx)(n.code,{children:"status"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Add a function property to ",(0,i.jsx)(n.code,{children:"schema.statics"})]}),"\n",(0,i.jsxs)(n.li,{children:["Call the ",(0,i.jsx)(n.code,{children:"Schema#static()"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// define a schema\nconst animalSchema = new Schema({ name: String, type: String },\n  {\n  // Assign a function to the \"statics\" object of our animalSchema through schema options.\n  // By following this approach, there is no need to create a separate TS type to define the type of the statics functions.\n    statics: {\n      findByName(name) {\n        return this.find({ name: new RegExp(name, 'i') });\n      }\n    }\n  });\n\n// Or, Assign a function to the \"statics\" object of our animalSchema\nanimalSchema.statics.findByName = function(name) {\n  return this.find({ name: new RegExp(name, 'i') });\n};\n// Or, equivalently, you can call `animalSchema.static()`.\nanimalSchema.static('findByBreed', function(breed) { return this.find({ breed }); });\n\nconst Animal = mongoose.model('Animal', animalSchema);\nlet animals = await Animal.findByName('fido');\nanimals = animals.concat(await Animal.findByBreed('Poodle'));\n"})}),"\n",(0,i.jsx)(n.h3,{id:"query-helpers",children:"Query Helpers"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Query helper functions can also be added:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"\n// define a schema\nconst animalSchema = new Schema({ name: String, type: String },\n  {\n  // Assign a function to the \"query\" object of our animalSchema through schema options.\n  // By following this approach, there is no need to create a separate TS type to define the type of the query functions.\n    query: {\n      byName(name) {\n        return this.where({ name: new RegExp(name, 'i') });\n      }\n    }\n  });\n\n// Or, Assign a function to the \"query\" object of our animalSchema\nanimalSchema.query.byName = function(name) {\n  return this.where({ name: new RegExp(name, 'i') });\n};\n\nconst Animal = mongoose.model('Animal', animalSchema);\n\nAnimal.find().byName('fido').exec((err, animals) => {\n  console.log(animals);\n});\n\nAnimal.findOne().byName('fido').exec((err, animal) => {\n  console.log(animal);\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"indexes",children:"Indexes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"MongoDB supports secondarily indexes."}),"\n",(0,i.jsx)(n.li,{children:"They can be defined at the path level or the schema level:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const animalSchema = new Schema({\n  name: String,\n  type: String,\n  tags: { type: [String], index: true } // path level\n});\n\nanimalSchema.index({ name: 1, type: -1 }); // schema level\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["When the application starts, Mongoose will automatically call ",(0,i.jsx)(n.code,{children:"createIndex"})," for each defined index in the schema."]}),"\n",(0,i.jsxs)(n.li,{children:["It is recommended to turn this feature off in production since it can cause a significant performance decrease.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This can be disabled in two different ways:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"At the schema level"}),"\n",(0,i.jsx)(n.li,{children:"At the global level"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"mongoose.connect('mongodb://user:pass@127.0.0.1:port/database', { autoIndex: false });\n// or\nmongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database', { autoIndex: false });\n// or\nmongoose.set('autoIndex', false);\n// or\nanimalSchema.set('autoIndex', false);\n// or\nnew Schema({ /* ... */ }, { autoIndex: false });\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["An ",(0,i.jsx)(n.code,{children:"index"})," event will be emitted on the model when indexes are done or an error occurs."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// Will cause an error because mongodb has an _id index by default that\n// is not sparse\nanimalSchema.index({ _id: 1 }, { sparse: true });\nconst Animal = mongoose.model('Animal', animalSchema);\n\nAnimal.on('index', error => {\n  // \"_id index cannot be sparse\"\n  console.log(error.message);\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"virtuals",children:"Virtuals"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Virtuals are document properties that can be set but do not get persisted to MongoDB."}),"\n",(0,i.jsx)(n.li,{children:"The getters are useful for formatting and combining fields while the setters are useful for de-composing a single value into multiple values for storage."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// define a schema\nconst personSchema = new Schema({\n  name: {\n    first: String,\n    last: String\n  }\n});\n\n// compile our model\nconst Person = mongoose.model('Person', personSchema);\n\n// create a document\nconst axl = new Person({\n  name: { first: 'Axl', last: 'Rose' }\n});\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Here is a good example for wanting to get the first and last name together:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// That can be done either by adding it to schema options:\nconst personSchema = new Schema({\n  name: {\n    first: String,\n    last: String\n  }\n}, {\n  virtuals: {\n    fullName: {\n      get() {\n        return this.name.first + ' ' + this.name.last;\n      }\n    }\n  }\n});\n\n// Or by using the virtual method as following:\npersonSchema.virtual('fullName').get(function() {\n  return this.name.first + ' ' + this.name.last;\n});\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Then you can just do: ",(0,i.jsx)(n.code,{children:"console.log(axl.fullName); // Axl Rose"})]}),"\n",(0,i.jsxs)(n.li,{children:["When using ",(0,i.jsx)(n.code,{children:"toJson"})," or ",(0,i.jsx)(n.code,{children:"toObject"}),", Mongoose does not include virtuals by default. Pass ",(0,i.jsx)(n.code,{children:"{ virtuals: true }"})," to include them."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// Convert `doc` to a POJO, with virtuals attached\ndoc.toObject({ virtuals: true });\n\n// Equivalent:\ndoc.toJSON({ virtuals: true });\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The same caveat applies to ",(0,i.jsx)(n.code,{children:"JSON.stringify()"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// Explicitly add virtuals to `JSON.stringify()` output\nJSON.stringify(doc.toObject({ virtuals: true }));\n\n// Or, to automatically attach virtuals to `JSON.stringify()` output:\nconst personSchema = new Schema({\n  name: {\n    first: String,\n    last: String\n  }\n}, {\n  toJSON: { virtuals: true } // <-- include virtuals in `JSON.stringify()`\n});\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Custom setters work as well:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// Again that can be done either by adding it to schema options:\nconst personSchema = new Schema({\n  name: {\n    first: String,\n    last: String\n  }\n}, {\n  virtuals: {\n    fullName: {\n      get() {\n        return this.name.first + ' ' + this.name.last;\n      },\n      set(v) {\n        this.name.first = v.substr(0, v.indexOf(' '));\n        this.name.last = v.substr(v.indexOf(' ') + 1);\n      }\n    }\n  }\n});\n\n// Or by using the virtual method as following:\npersonSchema.virtual('fullName').\n  get(function() {\n    return this.name.first + ' ' + this.name.last;\n  }).\n  set(function(v) {\n    this.name.first = v.substr(0, v.indexOf(' '));\n    this.name.last = v.substr(v.indexOf(' ') + 1);\n  });\n\naxl.fullName = 'William Rose'; // Now `axl.name.first` is \"William\"\n"})}),"\n",(0,i.jsx)(n.h3,{id:"aliases",children:"Aliases"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Aliases are a particular type of virtual where the getter and setter work together."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const personSchema = new Schema({\n  n: {\n    type: String,\n    // Now accessing `name` will get you the value of `n`, and setting `name` will set the value of `n`\n    alias: 'name'\n  }\n});\n\n// Setting `name` will propagate to `n`\nconst person = new Person({ name: 'Val' });\nconsole.log(person); // { n: 'Val' }\nconsole.log(person.toObject({ virtuals: true })); // { n: 'Val', name: 'Val' }\nconsole.log(person.name); // \"Val\"\n\nperson.name = 'Not Val';\nconsole.log(person); // { n: 'Not Val' }\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"This can also be done on nested schema:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const childSchema = new Schema({\n  n: {\n    type: String,\n    alias: 'name'\n  }\n}, { _id: false });\n\nconst parentSchema = new Schema({\n  // If in a child schema, alias doesn't need to include the full nested path\n  c: childSchema,\n  name: {\n    f: {\n      type: String,\n      // Alias needs to include the full nested path if declared inline\n      alias: 'name.first'\n    }\n  }\n});\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>l});var a=s(6540);const i={},o=a.createContext(i);function t(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);