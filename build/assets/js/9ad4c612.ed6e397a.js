"use strict";(self.webpackChunkjustinszaro_com_docs=self.webpackChunkjustinszaro_com_docs||[]).push([[999],{4805:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"React/packages/TanStackQuery/guides-and-concepts","title":"TanStackQuery Guides and Concepts","description":"Important Defaults","source":"@site/docs/React/packages/TanStackQuery/guides-and-concepts.md","sourceDirName":"React/packages/TanStackQuery","slug":"/React/packages/TanStackQuery/guides-and-concepts","permalink":"/docs/React/packages/TanStackQuery/guides-and-concepts","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"introduction","permalink":"/docs/React/packages/EasyPeasy/introduction"},"next":{"title":"Projects","permalink":"/docs/projects/"}}');var s=t(4848),a=t(8453);const r={},o="TanStackQuery Guides and Concepts",l={},d=[{value:"Important Defaults",id:"important-defaults",level:2},{value:"Queries",id:"queries",level:2},{value:"Query Basics",id:"query-basics",level:3},{value:"Fetch Status",id:"fetch-status",level:4},{value:"Why two different states?",id:"why-two-different-states",level:4},{value:"Query Keys",id:"query-keys",level:2},{value:"Simple Query Keys",id:"simple-query-keys",level:3},{value:"Array Key with Variables",id:"array-key-with-variables",level:3},{value:"Query Keys are hashed deterministically!!!",id:"query-keys-are-hashed-deterministically",level:3},{value:"If your query function depends on variables, include it in your query key.",id:"if-your-query-function-depends-on-variables-include-it-in-your-query-key",level:3},{value:"Query Functions",id:"query-functions",level:2},{value:"Handling and Throwing Errors",id:"handling-and-throwing-errors",level:4},{value:"Using With <code>fetch</code> and other clients that do not throw by default.",id:"using-with-fetch-and-other-clients-that-do-not-throw-by-default",level:4},{value:"Query Function Variables",id:"query-function-variables",level:4},{value:"QueryFunctionContext",id:"queryfunctioncontext",level:4},{value:"Query Options",id:"query-options",level:2},{value:"Network Mode",id:"network-mode",level:2},{value:"Network Mode: online (Default)",id:"network-mode-online-default",level:3},{value:"Network Mode: always",id:"network-mode-always",level:4},{value:"Network Mode: offlineFirst",id:"network-mode-offlinefirst",level:4},{value:"Parallel Queries",id:"parallel-queries",level:2},{value:"Manual Parallel Queries",id:"manual-parallel-queries",level:3},{value:"Dynamic Parallel Queries use <code>useQueries</code>",id:"dynamic-parallel-queries-use-usequeries",level:3},{value:"Dependent Queries",id:"dependent-queries",level:2},{value:"<code>useQueries</code> dependent Query",id:"usequeries-dependent-query",level:3},{value:"A note about performance:",id:"a-note-about-performance",level:3},{value:"Background Fetching Indicators",id:"background-fetching-indicators",level:2},{value:"Displaying the Global Background Fetching Loading State",id:"displaying-the-global-background-fetching-loading-state",level:3},{value:"Window Focus Refetching",id:"window-focus-refetching",level:2},{value:"Custom Window Focus Event",id:"custom-window-focus-event",level:3},{value:"Managing Focus in React Native",id:"managing-focus-in-react-native",level:3},{value:"Managing Focus State",id:"managing-focus-state",level:3},{value:"Disabling and Pausing Queries",id:"disabling-and-pausing-queries",level:2},{value:"Lazy Queries",id:"lazy-queries",level:3},{value:"isLoading (Previously: <code>isInitialLoading</code>)",id:"isloading-previously-isinitialloading",level:3},{value:"Query Retries",id:"query-retries",level:2},{value:"Retry Delay",id:"retry-delay",level:3},{value:"Paginated / Lagged Queries",id:"paginated--lagged-queries",level:2},{value:"Better Paginated Queries with <code>placeholderData</code>",id:"better-paginated-queries-with-placeholderdata",level:3},{value:"Lagging Infinite Query results with <code>placeholderData</code>",id:"lagging-infinite-query-results-with-placeholderdata",level:3},{value:"Infinite Queries",id:"infinite-queries",level:2},{value:"What happens when an infinite query needs to be re-fetched?",id:"what-happens-when-an-infinite-query-needs-to-be-re-fetched",level:3},{value:"What if I want to implement a bi-directional infinite list?",id:"what-if-i-want-to-implement-a-bi-directional-infinite-list",level:3},{value:"What if I want to show the pages in reverse order?",id:"what-if-i-want-to-show-the-pages-in-reverse-order",level:3},{value:"What if I want to manually update the infinite query?",id:"what-if-i-want-to-manually-update-the-infinite-query",level:3},{value:"Manually removing first page:",id:"manually-removing-first-page",level:4},{value:"Manually removing a single value from an individual page:",id:"manually-removing-a-single-value-from-an-individual-page",level:4},{value:"Keep only the first page:",id:"keep-only-the-first-page",level:4},{value:"What if I want limit the number of pages?",id:"what-if-i-want-limit-the-number-of-pages",level:3},{value:"What if my API doesn&#39;t return a cursor?",id:"what-if-my-api-doesnt-return-a-cursor",level:3},{value:"Initial Query Data",id:"initial-query-data",level:2},{value:"Using <code>initialData</code> to pre-populate a query",id:"using-initialdata-to-pre-populate-a-query",level:3},{value:"<code>stateTime</code> and <code>initialDataUpdatedAt</code>",id:"statetime-and-initialdataupdatedat",level:3},{value:"Initial Data Function",id:"initial-data-function",level:3},{value:"Initial Data from Cache",id:"initial-data-from-cache",level:3},{value:"Initial Data from the cache with <code>initialDataUpdatedAt</code>",id:"initial-data-from-the-cache-with-initialdataupdatedat",level:3},{value:"Conditional Initial Data from Cache",id:"conditional-initial-data-from-cache",level:3},{value:"Placeholder Query Data",id:"placeholder-query-data",level:2},{value:"Placeholder Data as a Value",id:"placeholder-data-as-a-value",level:3},{value:"Placeholder Data Memoize",id:"placeholder-data-memoize",level:3},{value:"Placeholder Data as a Function",id:"placeholder-data-as-a-function",level:3},{value:"Placeholder Data From Cache",id:"placeholder-data-from-cache",level:3},{value:"Mutations",id:"mutations",level:2},{value:"Resetting Mutation State",id:"resetting-mutation-state",level:3},{value:"Mutation Side Effects",id:"mutation-side-effects",level:3},{value:"Consecutive Mutations",id:"consecutive-mutations",level:4},{value:"Promises",id:"promises",level:3},{value:"Retry",id:"retry",level:3},{value:"Persist Mutations",id:"persist-mutations",level:3},{value:"Persisting Offline Mutations",id:"persisting-offline-mutations",level:4},{value:"Mutation Scopes",id:"mutation-scopes",level:3},{value:"Query Invalidation",id:"query-invalidation",level:2},{value:"Query Matching with <code>invalidateQueries</code>",id:"query-matching-with-invalidatequeries",level:3},{value:"Invalidations from Mutations",id:"invalidations-from-mutations",level:2},{value:"Updates from Mutation Responses",id:"updates-from-mutation-responses",level:2},{value:"Immutability",id:"immutability",level:3},{value:"Optimistic Updates",id:"optimistic-updates",level:2},{value:"Via the UI",id:"via-the-ui",level:3},{value:"If the mutation and the query do not live in the same component.",id:"if-the-mutation-and-the-query-do-not-live-in-the-same-component",level:3},{value:"Via the Cache",id:"via-the-cache",level:3},{value:"Updating a list of todos when adding a new todo",id:"updating-a-list-of-todos-when-adding-a-new-todo",level:4},{value:"Updating a single Todo",id:"updating-a-single-todo",level:4},{value:"When to use what",id:"when-to-use-what",level:3},{value:"Query Cancellation",id:"query-cancellation",level:2},{value:"Default Behavior",id:"default-behavior",level:3},{value:"Using <code>fetch</code>",id:"using-fetch",level:4},{value:"Using <code>axios</code> v0.22.0+",id:"using-axios-v0220",level:4},{value:"Using <code>axios</code> with version lower than <code>v0.22.0</code>",id:"using-axios-with-version-lower-than-v0220",level:4},{value:"Manual Cancellation",id:"manual-cancellation",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Testing",id:"testing",level:2},{value:"Our First Test",id:"our-first-test",level:3},{value:"Turn off Retries",id:"turn-off-retries",level:3},{value:"Setting gcTime to Infinity with Jest",id:"setting-gctime-to-infinity-with-jest",level:3},{value:"Testing Network Calls",id:"testing-network-calls",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"tanstackquery-guides-and-concepts",children:"TanStackQuery Guides and Concepts"})}),"\n",(0,s.jsx)(n.h2,{id:"important-defaults",children:"Important Defaults"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Out of box, TanStack Query is configured with aggressive but sane defaults."}),"\n",(0,s.jsxs)(n.li,{children:["The following is good to keep in mind when debugging/learning.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Query instances via ",(0,s.jsx)(n.code,{children:"useQuery"})," or ",(0,s.jsx)(n.code,{children:"useInfiniteQuery"})," by default consider cached data as stale.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["To change, you con configure globally or per query using the ",(0,s.jsx)(n.code,{children:"staleTime"})," option."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Stale queries are re-fetched automatically in the background when","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"New instances of the query mount"}),"\n",(0,s.jsx)(n.li,{children:"The window is refocused."}),"\n",(0,s.jsx)(n.li,{children:"The network is reconnected."}),"\n",(0,s.jsx)(n.li,{children:"The query is optionally configured with a refresh interval."}),"\n",(0,s.jsxs)(n.li,{children:["To change, you can use the following options:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"refetchOnMount"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"refetchOnWindowFocus"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"refetchOnReconnect"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"refetchInterval"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Query results have that have no more active instances of ",(0,s.jsx)(n.code,{children:"useQuery"}),", ",(0,s.jsx)(n.code,{children:"useInfiniteQuery"}),', or query observers are labeled as "inactive" and remain in the cache in case they are used again at a later time.']}),"\n",(0,s.jsxs)(n.li,{children:['By default, "inactive" queries are garbage collected after 5 minutes.',"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["To change, you can alter ",(0,s.jsx)(n.code,{children:"gcTime"})," for something other than 1000 _ 60 _ 5 milliseconds."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Queries that fail are silently retried 3 times with exponential backoff delay before being captured an sent to the UI.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["To change: you can alter ",(0,s.jsx)(n.code,{children:"retry"})," and ",(0,s.jsx)(n.code,{children:"retryDelay"})," options for queries to something other than the defaults."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Query results by default are structurally shared to detect if data has actually changed and if not, the data reference remains unchanged to better help with value stabilization with regards to useMemo and useCallback.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"99.9% of the time, this isn't an issue."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"queries",children:"Queries"}),"\n",(0,s.jsx)(n.h3,{id:"query-basics",children:"Query Basics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A query is a declarative dependency on an asynchronous source of data that is tied to a unique key."}),"\n",(0,s.jsx)(n.li,{children:"Queries can be used with any promise based method (including GET and POST api calls) to fetch data from a server. If the method modifies the data, it is recommended to use Mutations instead."}),"\n",(0,s.jsxs)(n.li,{children:["To subscribe to a query in a component or custom hook, use the ",(0,s.jsx)(n.code,{children:"useQuery"})," hook with at least,","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A unique key for the query"}),"\n",(0,s.jsxs)(n.li,{children:["A function that returns a promise that:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Resolves the data, or"}),"\n",(0,s.jsx)(n.li,{children:"Throws an error."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { useQuery } from "@tanstack/react-query";\n\nfunction App() {\n  const info = useQuery({ queryKey: ["todos"], queryFn: fetchTodoList });\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The unique key provided is used internally for refetching, caching, and sharing queries through the application."}),"\n",(0,s.jsxs)(n.li,{children:["The query result returned by ",(0,s.jsx)(n.code,{children:"useQuery"})," contains all the information about the query that is needed for templating or any other data usage."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'const result = useQuery({ queryKey: ["todos"], queryFn: fetchTodoList });\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The result object contains a few different states:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isPending"})," or ",(0,s.jsx)(n.code,{children:"status == 'pending'"})," - The query has no data yet."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isError"})," or ",(0,s.jsx)(n.code,{children:"status == 'error'"})," - The query encountered an error."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isSuccess"})," or ",(0,s.jsx)(n.code,{children:"status == 'success'"})," - The query was successful and data is available."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Beyond the states, more information is available depending on the states:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"error"})," - If the query errored, the error is available on the ",(0,s.jsx)(n.code,{children:"error"})," property."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data"})," - If the query is successful, the data is available on the ",(0,s.jsx)(n.code,{children:"data"})," property."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isFetching"})," - In any state, if the query is fetching at any time (including background refetching) ",(0,s.jsx)(n.code,{children:"isFetching"})," will be true."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["For most queries, it is usually sufficient to check for the ",(0,s.jsx)(n.code,{children:"isPending"})," state, then the ",(0,s.jsx)(n.code,{children:"isError"})," state, then finally assume that the data is available and render the successful state."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function Todos() {\n  const { isPending, isError, data, error } = useQuery({\n    queryKey: ["todos"],\n    queryFn: fetchTodoList,\n  });\n\n  if (isPending) {\n    return <span>Loading...</span>;\n  }\n\n  if (isError) {\n    return <span>Error: {error.message}</span>;\n  }\n\n  // We can assume by this point that `isSuccess === true`\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  );\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"or, if you don't prefer booleans"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function Todos() {\n  const { status, data, error } = useQuery({\n    queryKey: ["todos"],\n    queryFn: fetchTodoList,\n  });\n\n  if (status === "pending") {\n    return <span>Loading...</span>;\n  }\n\n  if (status === "error") {\n    return <span>Error: {error.message}</span>;\n  }\n\n  // also status === \'success\', but "else" logic works, too\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"fetch-status",children:"Fetch Status"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In addition to the status field, you will also get an additional ",(0,s.jsx)(n.code,{children:"fetchStatus"})," property with the following options","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fetchStatus == 'pending'"})," - The query is currently fetching."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fetchStatus == 'pausing'"})," - The query wanted to fetch, but is paused. (See Network Mode)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fetchStatus == 'idle'"})," - The query isn't doing anything."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"why-two-different-states",children:"Why two different states?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Background re-fetches and stale-while-revalidate logic make all combinations for status and fetchStatus possible."}),"\n",(0,s.jsxs)(n.li,{children:["A query can be in a ",(0,s.jsx)(n.code,{children:"pending"})," state without fetching any data. Keep in mind:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"status"})," gives information about the data (Is there any?)"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"fetchStatus"})," gives information about the ",(0,s.jsx)(n.code,{children:"queryFn"})," (Is it running?)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"query-keys",children:"Query Keys"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"At its core, TanStack query manages query caching based on the several query keys."}),"\n",(0,s.jsx)(n.li,{children:"At the top level they are an array, but can be as simple as an Array with a single string and as complex as an array of many strings and other nested objects."}),"\n",(0,s.jsx)(n.li,{children:"As long as the query key is serializable and unique, it can be used!"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"simple-query-keys",children:"Simple Query Keys"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The simplest form of a key is an array with constant values, which is useful for","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Generic List/Index resources"}),"\n",(0,s.jsx)(n.li,{children:"Non-Hierarchical resources"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// A list of todos\nuseQuery({ queryKey: ['todos'], ... })\n\n// Something else, whatever!\nuseQuery({ queryKey: ['something', 'special'], ... })\n"})}),"\n",(0,s.jsx)(n.h3,{id:"array-key-with-variables",children:"Array Key with Variables"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When a query needs to describe its data, you can use an array with a string and any serializable objects to describe it."}),"\n",(0,s.jsxs)(n.li,{children:["This is useful for","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Hierarchical or nested resources","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It is common to pass an id, index, or other primitive to uniquely identify the item."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Queries with additional parameters/","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It is common to pass an object of additional options."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// An individual todo\nuseQuery({ queryKey: ['todo', 5], ... })\n\n// An individual todo in a \"preview\" format\nuseQuery({ queryKey: ['todo', 5, { preview: true }], ...})\n\n// A list of todos that are \"done\"\nuseQuery({ queryKey: ['todos', { type: 'done' }], ... })\n"})}),"\n",(0,s.jsx)(n.h3,{id:"query-keys-are-hashed-deterministically",children:"Query Keys are hashed deterministically!!!"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"No matter the order of keys in objects, the following queries are considered equally."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"useQuery({ queryKey: ['todos', { status, page }], ... })\nuseQuery({ queryKey: ['todos', { page, status }], ...})\nuseQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The following query keys are not equal, since array order matters."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"useQuery({ queryKey: ['todos', status, page], ... })\nuseQuery({ queryKey: ['todos', page, status], ...})\nuseQuery({ queryKey: ['todos', undefined, page, status], ...})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"if-your-query-function-depends-on-variables-include-it-in-your-query-key",children:"If your query function depends on variables, include it in your query key."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Since query keys described the data they are fetching, they should include any variations in your query function that change."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function Todos({ todoId }) {\n  const result = useQuery({\n    queryKey: ["todos", todoId],\n    queryFn: () => fetchTodoById(todoId),\n  });\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Query Keys act as dependencies for your function."}),"\n",(0,s.jsx)(n.li,{children:"Adding dependent variables to your query key will ensure that queries are cached independently, and are re-fetched automatically anytime a variable changes."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"query-functions",children:"Query Functions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A query function is any function that returns a promise. That promise should either resolve the data or throw an error."}),"\n",(0,s.jsx)(n.li,{children:"The following are all valid query configurations:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'useQuery({ queryKey: ["todos"], queryFn: fetchAllTodos });\nuseQuery({ queryKey: ["todos", todoId], queryFn: () => fetchTodoById(todoId) });\nuseQuery({\n  queryKey: ["todos", todoId],\n  queryFn: async () => {\n    const data = await fetchTodoById(todoId);\n    return data;\n  },\n});\nuseQuery({\n  queryKey: ["todos", todoId],\n  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),\n});\n'})}),"\n",(0,s.jsx)(n.h4,{id:"handling-and-throwing-errors",children:"Handling and Throwing Errors"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"For TanStack query to determine a query errored, the query function must throw or return a rejected Promise."}),"\n",(0,s.jsx)(n.li,{children:"Any error that is thrown in the query function will be persisted in the error state of the query."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'const { error } = useQuery({\n  queryKey: ["todos", todoId],\n  queryFn: async () => {\n    if (somethingGoesWrong) {\n      throw new Error("Oh no!");\n    }\n    if (somethingElseGoesWrong) {\n      return Promise.reject(new Error("Oh no!"));\n    }\n\n    return data;\n  },\n});\n'})}),"\n",(0,s.jsxs)(n.h4,{id:"using-with-fetch-and-other-clients-that-do-not-throw-by-default",children:["Using With ",(0,s.jsx)(n.code,{children:"fetch"})," and other clients that do not throw by default."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["With most utilities like ",(0,s.jsx)(n.code,{children:"axios"})," and ",(0,s.jsx)(n.code,{children:"graphql-request"})," automatically throw errors for unsuccessful HTTP calls, some utilities like ",(0,s.jsx)(n.code,{children:"fetch"})," don't. In that case, throw them on your own."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'useQuery({\n  queryKey: ["todos", todoId],\n  queryFn: async () => {\n    const response = await fetch("/todos/" + todoId);\n    if (!response.ok) {\n      throw new Error("Network response was not ok");\n    }\n    return response.json();\n  },\n});\n'})}),"\n",(0,s.jsx)(n.h4,{id:"query-function-variables",children:"Query Function Variables"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Query keys are passed into your query function as part of the QueryFunctionContext."}),"\n",(0,s.jsx)(n.li,{children:"With not always needed, it makes it possible to extract your query functions if needed:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function Todos({ status, page }) {\n  const result = useQuery({\n    queryKey: ['todos', { status, page }],\n    queryFn: fetchTodoList,\n  })\n}\n\n// Access the key, status and page variables in your query function!\nfunction fetchTodoList({ queryKey }) {\n  const [_key, { status, page }] = queryKey\n  return new Promise()\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"queryfunctioncontext",children:"QueryFunctionContext"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The QueryFunctionContext is the object passed to every query function. It consists of","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"queryKey: QueryKey"})," - Query Keys"]}),"\n",(0,s.jsxs)(n.li,{children:["`signal?: Abort Signal","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal",children:"AbortSignal"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"meta: Record<string, unknown> | undefined"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"An optional field that you can fill in additional information about your query."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Infinite Queries get some additional information passed:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pageParam: tPageParam"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The page parameter used to fetch the current page."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"query-options",children:"Query Options"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["One of the best ways to share ",(0,s.jsx)(n.code,{children:"queryKey"})," and ",(0,s.jsx)(n.code,{children:"queryFn"})," between multiple places is to use the ",(0,s.jsx)(n.code,{children:"queryOptions"})," helper."]}),"\n",(0,s.jsx)(n.li,{children:"At runtime, the helper just returns whatever you pass info it."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { queryOptions } from "@tanstack/react-query";\n\nfunction groupOptions(id: number) {\n  return queryOptions({\n    queryKey: ["groups", id],\n    queryFn: () => fetchGroups(id),\n    staleTime: 5 * 1000,\n  });\n}\n\n// usage:\n\nuseQuery(groupOptions(1));\nuseSuspenseQuery(groupOptions(5));\nuseQueries({\n  queries: [groupOptions(1), groupOptions(2)],\n});\nqueryClient.prefetchQuery(groupOptions(23));\nqueryClient.setQueryData(groupOptions(42).queryKey, newGroups);\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For infinite queries, a separate ",(0,s.jsx)(n.code,{children:"infiniteQueryOptions"})," helper is available."]}),"\n",(0,s.jsxs)(n.li,{children:["You can still override some options at a component level. A very common and useful pattern is to create per-component ",(0,s.jsx)(n.code,{children:"select"})," functions."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Type inference still works, so query.data will be the return type of select instead of queryFn\n\nconst query = useQuery({\n  ...groupOptions(1),\n  select: (data) => data.groupName,\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"network-mode",children:"Network Mode"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"There are three different network modes to distinguish how Queries and Mutations should behave if there is no network connection."}),"\n",(0,s.jsx)(n.li,{children:"They can be set for each individually or globally."}),"\n",(0,s.jsxs)(n.li,{children:["The default network mode is ",(0,s.jsx)(n.code,{children:"online"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"network-mode-online-default",children:"Network Mode: online (Default)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"In this mode, queries and mutations will now fire unless you have a network connection."}),"\n",(0,s.jsx)(n.li,{children:"If a fetch is initiated, it was always stay in the state it is in if the fetch cannot be made because there is no network connection."}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"fetchStatus"})," is exposed additionally. It is either:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fetching"})," - The ",(0,s.jsx)(n.code,{children:"queryFn"})," is really exciting - a request is in-flight."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"paused"})," - The query is not executing - it is ",(0,s.jsx)(n.code,{children:"paused"})," until you have a connection again."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"idle"})," - The query is not fetching and not paused."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["The flags ",(0,s.jsx)(n.code,{children:"isFetching"})," and ",(0,s.jsx)(n.code,{children:"isPaused"})," are derived from this state and exposed for convenience."]}),"\n",(0,s.jsx)(n.li,{children:"If you are online and then go offline while the fetch is occurring, the retry mechanism will be paused. It will resume once you regain internet connection."}),"\n",(0,s.jsx)(n.li,{children:"If the query was cancelled, it will not resume once internet connection is established."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"network-mode-always",children:"Network Mode: always"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"TanStack Query will always ignore the online/offline state. This is better for an environment where you don't need internet connection for the queries to work."}),"\n",(0,s.jsx)(n.li,{children:"Queries will never be paused if there is no internet connection"}),"\n",(0,s.jsx)(n.li,{children:"Retries will not be paused"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"refetchOnConnect"})," defaults to false in this mode."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"network-mode-offlinefirst",children:"Network Mode: offlineFirst"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This is the middle ground between the three modes."}),"\n",(0,s.jsx)(n.li,{children:"The query will be run once, but all retires will be paused."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"parallel-queries",children:"Parallel Queries"}),"\n",(0,s.jsx)(n.p,{children:"Parallel Queries\n: Queries that are executed in parallel, or at the same time to maximize fetching concurrency."}),"\n",(0,s.jsx)(n.h3,{id:"manual-parallel-queries",children:"Manual Parallel Queries"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When the number of parallel queries does not change, there is no extra effort needed. Just use any number of ",(0,s.jsx)(n.code,{children:"useQuery"})," or ",(0,s.jsx)(n.code,{children:"useInfiniteQuery"})," hooks side-by-side!"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function App () {\n  // The following queries will execute in parallel\n  const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })\n  const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })\n  const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })\n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This does not work in suspense mode!"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"dynamic-parallel-queries-use-usequeries",children:["Dynamic Parallel Queries use ",(0,s.jsx)(n.code,{children:"useQueries"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If the number of queries changes depending on the render, you can use the ",(0,s.jsx)(n.code,{children:"useQueries"})," hook."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useQueries"})," accepts an options object with a query key where the value is an array of query objects. It returns the array of query results."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function App({ users }) {\n  const userQueries = useQueries({\n    queries: users.map((user) => {\n      return {\n        queryKey: ["user", user.id],\n        queryFn: () => fetchUserById(user.id),\n      };\n    }),\n  });\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"dependent-queries",children:"Dependent Queries"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Dependent (or Serial) queries depend on the previous ones before they can execute."}),"\n",(0,s.jsxs)(n.li,{children:["To do this, you can use the ",(0,s.jsx)(n.code,{children:"enabled"})," option to tell a query when it is ready to run."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// Get the user\nconst { data: user } = useQuery({\n  queryKey: ["user", email],\n  queryFn: getUserByEmail,\n});\n\nconst userId = user?.id;\n\n// Then get the user\'s projects\nconst {\n  status,\n  fetchStatus,\n  data: projects,\n} = useQuery({\n  queryKey: ["projects", userId],\n  queryFn: getProjectsByUser,\n  // The query will not execute until the userId exists\n  enabled: !!userId,\n});\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"usequeries-dependent-query",children:[(0,s.jsx)(n.code,{children:"useQueries"})," dependent Query"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useQueries"})," can depend on a previous Query as well:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// Get the users ids\nconst { data: userIds } = useQuery({\n  queryKey: ["users"],\n  queryFn: getUsersData,\n  select: (users) => users.map((user) => user.id),\n});\n\n// Then get the users messages\nconst usersMessages = useQueries({\n  queries: userIds\n    ? userIds.map((id) => {\n        return {\n          queryKey: ["messages", id],\n          queryFn: () => getMessagesByUsers(id),\n        };\n      })\n    : [], // if users is undefined, an empty array will be returned\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"a-note-about-performance",children:"A note about performance:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Dependent queries produce a request waterfall, which can hurt performance. It is best to flatten the waterfall if possible."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"background-fetching-indicators",children:"Background Fetching Indicators"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A query's ",(0,s.jsx)(n.code,{children:"status === 'pending'"})," is enough to show the hard-loading state for the query."]}),"\n",(0,s.jsx)(n.li,{children:"Sometimes, you may want to show an additional indicator that the query if refetching in the background."}),"\n",(0,s.jsxs)(n.li,{children:["You can do this with the ",(0,s.jsx)(n.code,{children:"isFetching"})," boolean, regardless of the status variable."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function Todos() {\n  const {\n    status,\n    data: todos,\n    error,\n    isFetching,\n  } = useQuery({\n    queryKey: ["todos"],\n    queryFn: fetchTodos,\n  });\n\n  return status === "pending" ? (\n    <span>Loading...</span>\n  ) : status === "error" ? (\n    <span>Error: {error.message}</span>\n  ) : (\n    <>\n      {isFetching ? <div>Refreshing...</div> : null}\n\n      <div>\n        {todos.map((todo) => (\n          <Todo todo={todo} />\n        ))}\n      </div>\n    </>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"displaying-the-global-background-fetching-loading-state",children:"Displaying the Global Background Fetching Loading State"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You can configure a global loading indicator when any queries are fetching (including in the background)."}),"\n",(0,s.jsxs)(n.li,{children:["You use the ",(0,s.jsx)(n.code,{children:"useIsFetching"})," hook."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { useIsFetching } from "@tanstack/react-query";\n\nfunction GlobalLoadingIndicator() {\n  const isFetching = useIsFetching();\n\n  return isFetching ? (\n    <div>Queries are fetching in the background...</div>\n  ) : null;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"window-focus-refetching",children:"Window Focus Refetching"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If a user leaves your application and the data goes stale, TanStack Query automatically refreshes the data when the user returns."}),"\n",(0,s.jsx)(n.li,{children:"This can be disabled globally by doing:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      refetchOnWindowFocus: false, // default: true\n    },\n  },\n});\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>;\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This can be disabled per query by doing:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'useQuery({\n  queryKey: ["todos"],\n  queryFn: fetchTodos,\n  refetchOnWindowFocus: false,\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"custom-window-focus-event",children:"Custom Window Focus Event"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"In rare circumstances, you may want to manage your own window focus events that trigger TanStackQuery to revalidate."}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"focusManager.setEventListener"})," is provided tht allows you to add a callback that should be fired when a window is focused."]}),"\n",(0,s.jsx)(n.li,{children:"The following is the default handler:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"focusManager.setEventListener((handleFocus) => {\n  // Listen to visibility change\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    const visibilityChangeHandler = () => {\n      handleFocus(document.visibilityState === 'visible')\n    }\n    window.addEventListener('visibilityChange', visibilityChangeHandler, false)\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener('visibilityChange', visibilityChangeHandler)\n    }\n  }\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"managing-focus-in-react-native",children:"Managing Focus in React Native"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Instead of event listeners on window, React Native provides focus information in the ",(0,s.jsx)(n.code,{children:"AppState"})," module."]}),"\n",(0,s.jsxs)(n.li,{children:["You can use the ",(0,s.jsx)(n.code,{children:"AppState"}),' "change" event to trigger an update when the app state changes back to active.']}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { AppState } from 'react-native'\nimport { focusManager } from '@tanstack/react-query'\n\nfunction onAppStateChange(status: AppStateStatus) {\n  if (Platform.OS !== 'web') {\n    focusManager.setFocused(status === 'active')\n  }\n}\n\nuseEffect(() => {\n  const subscription = AppState.addEventListener('change', onAppStateChange)\n\n  return () => subscription.remove()\n}, [])\n"})}),"\n",(0,s.jsx)(n.h3,{id:"managing-focus-state",children:"Managing Focus State"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { focusManager } from '@tanstack/react-query'\n\n// Override the default focus state\nfocusManager.setFocused(true)\n\n// Fallback to the default focus check\nfocusManager.setFocused(undefined)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"disabling-and-pausing-queries",children:"Disabling and Pausing Queries"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you ever want to disable a query from running automatically, you can use the ",(0,s.jsx)(n.code,{children:"enabled = false"})," option."]}),"\n",(0,s.jsx)(n.li,{children:"The enabled option can also take a callback as an option."}),"\n",(0,s.jsxs)(n.li,{children:["When enabled is false:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If the query has cached data, then the query will be initialized in the ",(0,s.jsx)(n.code,{children:"status === 'success'"})," or ",(0,s.jsx)(n.code,{children:"isSuccess"})," state."]}),"\n",(0,s.jsxs)(n.li,{children:["If the query does not have cached data, then the query will start in the ",(0,s.jsx)(n.code,{children:"status === 'pending'"})," and ",(0,s.jsx)(n.code,{children:"fetchStatus === 'idle'"})," state."]}),"\n",(0,s.jsx)(n.li,{children:"The query will not automatically fetch on mount."}),"\n",(0,s.jsx)(n.li,{children:"The query will not automatically refetch in the background."}),"\n",(0,s.jsxs)(n.li,{children:["The query will ignore query client ",(0,s.jsx)(n.code,{children:"invalidateQueries"})," and ",(0,s.jsx)(n.code,{children:"refetchQueries"})," calls that would normally result in the query refetching."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"refetch"})," returned from ",(0,s.jsx)(n.code,{children:"useQuery"})," can be used to manually trigger the query to fetch. However, it will not work with ",(0,s.jsx)(n.code,{children:"skipToken"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function Todos() {\n  const { isLoading, isError, data, error, refetch, isFetching } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n    enabled: false,\n  })\n\n  return (\n    <div>\n      <button onClick={() => refetch()}>Fetch Todos</button>\n\n      {data ? (\n        <>\n          <ul>\n            {data.map((todo) => (\n              <li key={todo.id}>{todo.title}</li>\n            ))}\n          </ul>\n        </>\n      ) : isError ? (\n        <span>Error: {error.message}</span>\n      ) : isLoading ? (\n        <span>Loading...</span>\n      ) : (\n        <span>Not ready ...</span>\n      )}\n\n      <div>{isFetching ? 'Fetching...' : null}</div>\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"lazy-queries",children:"Lazy Queries"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The enabled option can be used to permanently disable a query, but it can also enable / disable it at a later time."}),"\n",(0,s.jsx)(n.li,{children:"An example of this would be when you want form to fire off the first request when the user enters a filter value."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function Todos() {\n  const [filter, setFilter] = React.useState('')\n\n  const { data } = useQuery({\n    queryKey: ['todos', filter],\n    queryFn: () => fetchTodos(filter),\n    // \u2b07\ufe0f disabled as long as the filter is empty\n    enabled: !!filter,\n  })\n\n  return (\n    <div>\n      // \ud83d\ude80 applying the filter will enable and execute the query\n      <FiltersForm onApply={setFilter} />\n      {data && <TodosTable data={data} />}\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"isloading-previously-isinitialloading",children:["isLoading (Previously: ",(0,s.jsx)(n.code,{children:"isInitialLoading"}),")"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Lazy queries will have ",(0,s.jsx)(n.code,{children:"status: 'pending'"})," right from the start because there is no data yet. This means that you cannot use this flag to show a loading spinner."]}),"\n",(0,s.jsxs)(n.li,{children:["If you are disabling or using lazy queries, you can use the ",(0,s.jsx)(n.code,{children:"isLoading"})," flag instead."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"isLoading"})," flag is derived from ",(0,s.jsx)(n.code,{children:"isPending && isFetching"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"query-retries",children:"Query Retries"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When a ",(0,s.jsx)(n.code,{children:"useQuery"})," fails and throws an error, the query will be automatically retried if it has not reached the maximum number of consecutive retries."]}),"\n",(0,s.jsxs)(n.li,{children:["You can configure retries on a global or individual query level.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Setting ",(0,s.jsx)(n.code,{children:"retry = false"})," disables retries."]}),"\n",(0,s.jsxs)(n.li,{children:["Setting ",(0,s.jsx)(n.code,{children:"retry = 6"})," will retry six times before showing the final error thrown by the function."]}),"\n",(0,s.jsxs)(n.li,{children:["Setting ",(0,s.jsx)(n.code,{children:"retry = true"})," will infinitely retry failing requests."]}),"\n",(0,s.jsxs)(n.li,{children:["Setting ",(0,s.jsx)(n.code,{children:"retry = (failureCount, error) => ..."})," allows for custom logic."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useQuery } from '@tanstack/react-query'\n\n// Make a specific query retry a certain number of times\nconst result = useQuery({\n  queryKey: ['todos', 1],\n  queryFn: fetchTodoListPage,\n  retry: 10, // Will retry failed requests 10 times before displaying an error\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"retry-delay",children:"Retry Delay"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"By default, retries in TanStack Query do not happen immediately after a request fails."}),"\n",(0,s.jsxs)(n.li,{children:["The default ",(0,s.jsx)(n.code,{children:"retryDelay"})," is set to double each attempt (starting at ",(0,s.jsx)(n.code,{children:"1000"}),"ms), but doesn't exceed 30 seconds."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Configure for all queries\nimport {\n  QueryCache,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n    },\n  },\n})\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"paginated--lagged-queries",children:"Paginated / Lagged Queries"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Paginated data works by including the page information in the query key."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const result = useQuery({\n  queryKey: ['projects', page],\n  queryFn: fetchProjects,\n})\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If this example is run, you'll notice that the UI jumps in and out."}),"\n",(0,s.jsx)(n.li,{children:"To get around this, TanStack query uses something called PlaceHolder Data."}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"better-paginated-queries-with-placeholderdata",children:["Better Paginated Queries with ",(0,s.jsx)(n.code,{children:"placeholderData"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["By setting ",(0,s.jsx)(n.code,{children:"placeholderData"})," to ",(0,s.jsx)(n.code,{children:"(previousData) => previousData"})," or ",(0,s.jsx)(n.code,{children:"keepPreviousData"})," function exported from TanStack Query, you can do a few new things.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The data from the last fetch will still be available while the new data is being fetched, even though the query key is changed."}),"\n",(0,s.jsx)(n.li,{children:"When the new data arrives, it is seamlessly swapped out with the old data."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isPlaceholderData"})," is made available to know what data the query is currently providing you."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { keepPreviousData, useQuery } from '@tanstack/react-query'\nimport React from 'react'\n\nfunction Todos() {\n  const [page, setPage] = React.useState(0)\n\n  const fetchProjects = (page = 0) =>\n    fetch('/api/projects?page=' + page).then((res) => res.json())\n\n  const { isPending, isError, error, data, isFetching, isPlaceholderData } =\n    useQuery({\n      queryKey: ['projects', page],\n      queryFn: () => fetchProjects(page),\n      placeholderData: keepPreviousData,\n    })\n\n  return (\n    <div>\n      {isPending ? (\n        <div>Loading...</div>\n      ) : isError ? (\n        <div>Error: {error.message}</div>\n      ) : (\n        <div>\n          {data.projects.map((project) => (\n            <p key={project.id}>{project.name}</p>\n          ))}\n        </div>\n      )}\n      <span>Current Page: {page + 1}</span>\n      <button\n        onClick={() => setPage((old) => Math.max(old - 1, 0))}\n        disabled={page === 0}\n      >\n        Previous Page\n      </button>\n      <button\n        onClick={() => {\n          if (!isPlaceholderData && data.hasMore) {\n            setPage((old) => old + 1)\n          }\n        }}\n        // Disable the Next Page button until we know a next page is available\n        disabled={isPlaceholderData || !data?.hasMore}\n      >\n        Next Page\n      </button>\n      {isFetching ? <span> Loading...</span> : null}\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"lagging-infinite-query-results-with-placeholderdata",children:["Lagging Infinite Query results with ",(0,s.jsx)(n.code,{children:"placeholderData"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"placeholderData"})," option also works with ",(0,s.jsx)(n.code,{children:"useInfiniteQuery"})," hook."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"infinite-queries",children:"Infinite Queries"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Rendering lists that can additively "load more" data onto an existing set or "infinitely scroll" is a common UI pattern.'}),"\n",(0,s.jsxs)(n.li,{children:["In this use case, you can use ",(0,s.jsx)(n.code,{children:"useInfiniteQuery"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["There are a few things different about ",(0,s.jsx)(n.code,{children:"useInfiniteQuery"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data"})," is not an object containing infinite query data."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data.pages"})," array contains the fetched pages."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data.pageParams"})," array contains the page params used to fetch the pages."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"fetchNextPage"})," and ",(0,s.jsx)(n.code,{children:"fetchPreviousPage"})," functions are available."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"initialPageParam"})," option is available to specify the initial page param."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"getNextPageParam"})," and ",(0,s.jsx)(n.code,{children:"getPreviousPageParam"})," options are available for determining if there is more data to load and the info to fetch it."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"hasNextPage"})," boolean is available."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"hasPreviousPage"})," boolean is available."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"isFetchingNextPage"})," and ",(0,s.jsx)(n.code,{children:"isFetchingPreviousPage"})," booleans are now available."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Example: There is an API that returns pages of 3 projects at a time based on a cursor index."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"fetch('/api/projects?cursor=0')\n// { data: [...], nextCursor: 3}\nfetch('/api/projects?cursor=3')\n// { data: [...], nextCursor: 6}\nfetch('/api/projects?cursor=6')\n// { data: [...], nextCursor: 9}\nfetch('/api/projects?cursor=9')\n// { data: [...] }\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:['In this case, you can make a "Load More" UI by:',"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Waiting for ",(0,s.jsx)(n.code,{children:"useInfiniteQuery"})," to request the first group of data by default."]}),"\n",(0,s.jsxs)(n.li,{children:["Returning the information for the next query in ",(0,s.jsx)(n.code,{children:"getNextPageParam"})]}),"\n",(0,s.jsxs)(n.li,{children:["Calling ",(0,s.jsx)(n.code,{children:"fetchNextPage"})," function"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useInfiniteQuery } from '@tanstack/react-query'\n\nfunction Projects() {\n  const fetchProjects = async ({ pageParam }) => {\n    const res = await fetch('/api/projects?cursor=' + pageParam)\n    return res.json()\n  }\n\n  const {\n    data,\n    error,\n    fetchNextPage,\n    hasNextPage,\n    isFetching,\n    isFetchingNextPage,\n    status,\n  } = useInfiniteQuery({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  })\n\n  return status === 'pending' ? (\n    <p>Loading...</p>\n  ) : status === 'error' ? (\n    <p>Error: {error.message}</p>\n  ) : (\n    <>\n      {data.pages.map((group, i) => (\n        <React.Fragment key={i}>\n          {group.data.map((project) => (\n            <p key={project.id}>{project.name}</p>\n          ))}\n        </React.Fragment>\n      ))}\n      <div>\n        <button\n          onClick={() => fetchNextPage()}\n          disabled={!hasNextPage || isFetchingNextPage}\n        >\n          {isFetchingNextPage\n            ? 'Loading more...'\n            : hasNextPage\n              ? 'Load More'\n              : 'Nothing more to load'}\n        </button>\n      </div>\n      <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>\n    </>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Calling ",(0,s.jsx)(n.code,{children:"fetchNextPage"})," while an ongoing fetch is in progress risks overwritten data happening in the background."]}),"\n",(0,s.jsx)(n.li,{children:"At all times, there can only be a single fetch for an Infinite Query at a time."}),"\n",(0,s.jsxs)(n.li,{children:["If you want to enable simultaneous fetching, you can do ",(0,s.jsx)(n.code,{children:"{ cancelRefetch: false }"})," option within ",(0,s.jsx)(n.code,{children:"fetchNextPage"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"what-happens-when-an-infinite-query-needs-to-be-re-fetched",children:"What happens when an infinite query needs to be re-fetched?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Each group is re-fetched sequentially."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"what-if-i-want-to-implement-a-bi-directional-infinite-list",children:"What if I want to implement a bi-directional infinite list?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Bi-Direction infinite lists can be implemented using ",(0,s.jsx)(n.code,{children:"getPreviousPageParam"}),", ",(0,s.jsx)(n.code,{children:"fetchPreviousPage"}),", ",(0,s.jsx)(n.code,{children:"hasPreviousPage"})," and ",(0,s.jsx)(n.code,{children:"isFetchingPreviousPage"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"what-if-i-want-to-show-the-pages-in-reverse-order",children:"What if I want to show the pages in reverse order?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You can use the select option:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  select: (data) => ({\n    pages: [...data.pages].reverse(),\n    pageParams: [...data.pageParams].reverse(),\n  }),\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"what-if-i-want-to-manually-update-the-infinite-query",children:"What if I want to manually update the infinite query?"}),"\n",(0,s.jsx)(n.h4,{id:"manually-removing-first-page",children:"Manually removing first page:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"queryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(1),\n  pageParams: data.pageParams.slice(1),\n}))\n"})}),"\n",(0,s.jsx)(n.h4,{id:"manually-removing-a-single-value-from-an-individual-page",children:"Manually removing a single value from an individual page:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const newPagesArray =\n  oldPagesArray?.pages.map((page) =>\n    page.filter((val) => val.id !== updatedId),\n  ) ?? []\n\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: newPagesArray,\n  pageParams: data.pageParams,\n}))\n"})}),"\n",(0,s.jsx)(n.h4,{id:"keep-only-the-first-page",children:"Keep only the first page:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"queryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(0, 1),\n  pageParams: data.pageParams.slice(0, 1),\n}))\n"})}),"\n",(0,s.jsx)(n.h3,{id:"what-if-i-want-limit-the-number-of-pages",children:"What if I want limit the number of pages?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In some cases, you may want to limit the pages stored in query data to improve the performance and UX.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When the user can load a large number of pages (memory usage)"}),"\n",(0,s.jsx)(n.li,{children:"When you have to refetch an infinite query that contains dozens of pages (network usage: all the pages are sequentially fetched)"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:'The solution is to use a "Limited Infinite Query".'}),"\n",(0,s.jsxs)(n.li,{children:["Set the ",(0,s.jsx)(n.code,{children:"maxPages"})," option in conjunction with the ",(0,s.jsx)(n.code,{children:"getNextPageParam"})," and ",(0,s.jsx)(n.code,{children:"getPreviousPageParam"})," to allow fetching pages when needed in both directions."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n  maxPages: 3,\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"what-if-my-api-doesnt-return-a-cursor",children:"What if my API doesn't return a cursor?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["You can use the ",(0,s.jsx)(n.code,{children:"pageParam"})," as a cursor. Because ",(0,s.jsx)(n.code,{children:"getNextPageParam"})," and ",(0,s.jsx)(n.code,{children:"getPreviousPageParam"})," also get the ",(0,s.jsx)(n.code,{children:"pageParam"})," of the current page, you can use it to calculate the next / previous page param."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"return useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, allPages, lastPageParam) => {\n    if (lastPage.length === 0) {\n      return undefined\n    }\n    return lastPageParam + 1\n  },\n  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {\n    if (firstPageParam <= 1) {\n      return undefined\n    }\n    return firstPageParam - 1\n  },\n})\n"})}),"\n",(0,s.jsx)(n.h2,{id:"initial-query-data",children:"Initial Query Data"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["There are many ways to supply initial data for a query to the cache before needing it:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Declaratively: Provide ",(0,s.jsx)(n.code,{children:"initialData"})," to a query to pre-populate it's cache if empty."]}),"\n",(0,s.jsxs)(n.li,{children:["Imperatively:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Prefetch the data using ",(0,s.jsx)(n.code,{children:"queryClient.prefetchQuery"})]}),"\n",(0,s.jsxs)(n.li,{children:["Manually place the data into the cache using ",(0,s.jsx)(n.code,{children:"queryClient.setQueryData"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"using-initialdata-to-pre-populate-a-query",children:["Using ",(0,s.jsx)(n.code,{children:"initialData"})," to pre-populate a query"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When you already have the data prepared in your app, you can provide it directly to the query."}),"\n",(0,s.jsxs)(n.li,{children:["If this is the case, you can use ",(0,s.jsx)(n.code,{children:"config.initialData"})," option to set the initial data for the query and skip the loading state."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"statetime-and-initialdataupdatedat",children:[(0,s.jsx)(n.code,{children:"stateTime"})," and ",(0,s.jsx)(n.code,{children:"initialDataUpdatedAt"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["By default, ",(0,s.jsx)(n.code,{children:"initialData"})," is treated as totally fresh, as if it was just fetched. This means that it will affect how it is interpreted by the ",(0,s.jsx)(n.code,{children:"staleTime"})," option.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If the query observer is configured with ",(0,s.jsx)(n.code,{children:"initialData"}),", and no ",(0,s.jsx)(n.code,{children:"staleTime"})," (Default 0), the query will immediately refetch when it mounts."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Will show initialTodos immediately, but also immediately refetch todos after mount\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you configure your query observer with ",(0,s.jsx)(n.code,{children:"initialData"})," and a ",(0,s.jsx)(n.code,{children:"staleTime"})," of 1000ms, the data will be considered fresh for that amount of time."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 1000,\n})\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If the ",(0,s.jsx)(n.code,{children:"initialData"})," isn't fresh, use can use the ",(0,s.jsx)(n.code,{children:"initialDataUpdatedAt"})," option. You can pass a numeric Javascript timestamp in ms of when the data was last updated."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 60 * 1000, // 1 minute\n  // This could be 10 seconds ago or 10 minutes ago\n  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"initial-data-function",children:"Initial Data Function"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If the process for accessing a query's initial data is intensive or not something you want to do on every render, you can pass the function as an ",(0,s.jsx)(n.code,{children:"initialData"})," value."]}),"\n",(0,s.jsx)(n.li,{children:"The function will only be executed once when the query is initialized."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: () => getExpensiveTodos(),\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"initial-data-from-cache",children:"Initial Data from Cache"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You can also provide initial data for a query from the cached result of another. This is great for adding the result of an individual item from a list."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch('/todos'),\n  initialData: () => {\n    // Use a todo from the 'todos' query as the initial data for this todo query\n    return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)\n  },\n})\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"initial-data-from-the-cache-with-initialdataupdatedat",children:["Initial Data from the cache with ",(0,s.jsx)(n.code,{children:"initialDataUpdatedAt"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Getting initial data from the cache means the source query is likely old."}),"\n",(0,s.jsxs)(n.li,{children:["It is suggested that you pass the source query's ",(0,s.jsx)(n.code,{children:"dataUpdatedAt"})," to ",(0,s.jsx)(n.code,{children:"initialDataUpdatedAt"})," to allow it be re-fetched if needed."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const result = useQuery({\n  queryKey: ['todos', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () =>\n    queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),\n  initialDataUpdatedAt: () =>\n    queryClient.getQueryState(['todos'])?.dataUpdatedAt,\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"conditional-initial-data-from-cache",children:"Conditional Initial Data from Cache"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If the cached source information is old, you may not want it at all."}),"\n",(0,s.jsxs)(n.li,{children:["You can use the ",(0,s.jsx)(n.code,{children:"queryClient.getQueryState"})," method instead to get more information about the source query, including a ",(0,s.jsx)(n.code,{children:"state.dataUpdatedAt"}),' timestamp you can use to decide if the query is "fresh" enough.']}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () => {\n    // Get the query state\n    const state = queryClient.getQueryState(['todos'])\n\n    // If the query exists and has data that is no older than 10 seconds...\n    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {\n      // return the individual todo\n      return state.data.find((d) => d.id === todoId)\n    }\n\n    // Otherwise, return undefined and let it fetch from a hard loading state!\n  },\n})\n"})}),"\n",(0,s.jsx)(n.h2,{id:"placeholder-query-data",children:"Placeholder Query Data"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Place holder data allows the query to already behave as if it has data, similarly to ",(0,s.jsx)(n.code,{children:"initialData"}),", but the data is not persisted to the cache."]}),"\n",(0,s.jsx)(n.li,{children:"This can be used when you have enough partial or fake data to render the query successfully while the rest of the data is fetching in the background."}),"\n",(0,s.jsxs)(n.li,{children:["There are a few different ways to supply placeholder data:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Declaratively - Provide ",(0,s.jsx)(n.code,{children:"placeholderData"})," to the query to populate the cache if empty."]}),"\n",(0,s.jsxs)(n.li,{children:["Imperatively - Prefetch or fetch the data using ",(0,s.jsx)(n.code,{children:"queryClient"})," and the ",(0,s.jsx)(n.code,{children:"placeholderData"})," option."]}),"\n",(0,s.jsxs)(n.li,{children:["Since there is data being displayed, ",(0,s.jsx)(n.code,{children:"status"})," will be in a success state. Instead, you can use the ",(0,s.jsx)(n.code,{children:"isPlaceholderData"})," to check."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"placeholder-data-as-a-value",children:"Placeholder Data as a Value"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function Todos() {\n  const result = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n    placeholderData: placeholderTodos,\n  })\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"placeholder-data-memoize",children:"Placeholder Data Memoize"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If accessing a query's placeholder data is intensive, you can memoize the value:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function Todos() {\n  const placeholderData = useMemo(() => generateFakeTodos(), [])\n  const result = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n    placeholderData,\n  })\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"placeholder-data-as-a-function",children:"Placeholder Data as a Function"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"placeholderData"})," can be a function, where you could get access to a previous query."]}),"\n",(0,s.jsx)(n.li,{children:"For example, when changing to todo 2 instead of todo 1, we can leave todo 1's data displayed."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const result = useQuery({\n  queryKey: ['todos', id],\n  queryFn: () => fetch(`/todos/${id}`),\n  placeholderData: (previousData, previousQuery) => previousData,\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"placeholder-data-from-cache",children:"Placeholder Data From Cache"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"In some cases, you can provide placeholder data from the cache of another query."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function Todo({ blogPostId }) {\n  const queryClient = useQueryClient()\n  const result = useQuery({\n    queryKey: ['blogPost', blogPostId],\n    queryFn: () => fetch(`/blogPosts/${blogPostId}`),\n    placeholderData: () => {\n      // Use the smaller/preview version of the blogPost from the 'blogPosts'\n      // query as the placeholder data for this blogPost query\n      return queryClient\n        .getQueryData(['blogPosts'])\n        ?.find((d) => d.id === blogPostId)\n    },\n  })\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"mutations",children:"Mutations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Mutations do create, update, and delete operations, along with performing server side-effects."}),"\n",(0,s.jsxs)(n.li,{children:["For these purposes, you can use the ",(0,s.jsx)(n.code,{children:"useMutation"})," hook."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function App() {\n  const mutation = useMutation({\n    mutationFn: (newTodo) => {\n      return axios.post('/todos', newTodo)\n    },\n  })\n\n  return (\n    <div>\n      {mutation.isPending ? (\n        'Adding todo...'\n      ) : (\n        <>\n          {mutation.isError ? (\n            <div>An error occurred: {mutation.error.message}</div>\n          ) : null}\n\n          {mutation.isSuccess ? <div>Todo added!</div> : null}\n\n          <button\n            onClick={() => {\n              mutation.mutate({ id: new Date(), title: 'Do Laundry' })\n            }}\n          >\n            Create Todo\n          </button>\n        </>\n      )}\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A Mutation can having the following states:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isIdle"})," or ",(0,s.jsx)(n.code,{children:"status == 'idle'"})," - The mutation is currently idle or in a fresh/reset state."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isPending"})," or ",(0,s.jsx)(n.code,{children:"status === 'pending'"})," - The mutation is currently running"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isError"})," or ",(0,s.jsx)(n.code,{children:"status === 'error'"})," - The mutation encountered an error"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isSuccess"})," or ",(0,s.jsx)(n.code,{children:"status === 'success'"})," - The mutation was successful and mutation data is available"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["There is also information available depending on the state:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"error"})," - If the mutation is in an ",(0,s.jsx)(n.code,{children:"error"})," state, the error is available via the ",(0,s.jsx)(n.code,{children:"error"})," property."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data"})," - If the mutation is in a ",(0,s.jsx)(n.code,{children:"success"})," state, the data is available via the ",(0,s.jsx)(n.code,{children:"data"})," property."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"In the example above, a single variable or object is passed to the mutation."}),"\n",(0,s.jsxs)(n.li,{children:["With the mutations onSuccess option, the ",(0,s.jsx)(n.code,{children:"invalidateQueries"})," method and the ",(0,s.jsx)(n.code,{children:"setQueryData"})," method, mutations can become extremely powerful."]}),"\n",(0,s.jsxs)(n.li,{children:["The mutate is an asynchronous function, so you need to wrap the ",(0,s.jsx)(n.code,{children:"mutate"})," in another function."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// This will not work in React 16 and earlier\nconst CreateTodo = () => {\n  const mutation = useMutation({\n    mutationFn: (event) => {\n      event.preventDefault()\n      return fetch('/api', new FormData(event.target))\n    },\n  })\n\n  return <form onSubmit={mutation.mutate}>...</form>\n}\n\n// This will work\nconst CreateTodo = () => {\n  const mutation = useMutation({\n    mutationFn: (formData) => {\n      return fetch('/api', formData)\n    },\n  })\n  const onSubmit = (event) => {\n    event.preventDefault()\n    mutation.mutate(new FormData(event.target))\n  }\n\n  return <form onSubmit={onSubmit}>...</form>\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"resetting-mutation-state",children:"Resetting Mutation State"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you need to clear the ",(0,s.jsx)(n.code,{children:"error"})," and ",(0,s.jsx)(n.code,{children:"data"})," of a mutation, you can use the ",(0,s.jsx)(n.code,{children:"reset"})," function."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'const CreateTodo = () => {\n  const [title, setTitle] = useState(\'\')\n  const mutation = useMutation({ mutationFn: createTodo })\n\n  const onCreateTodo = (e) => {\n    e.preventDefault()\n    mutation.mutate({ title })\n  }\n\n  return (\n    <form onSubmit={onCreateTodo}>\n      {mutation.error && (\n        <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>\n      )}\n      <input\n        type="text"\n        value={title}\n        onChange={(e) => setTitle(e.target.value)}\n      />\n      <br />\n      <button type="submit">Create Todo</button>\n    </form>\n  )\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"mutation-side-effects",children:"Mutation Side Effects"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useMutation"})," comes with some helper options to allow quick and easy side-effects."]}),"\n",(0,s.jsx)(n.li,{children:"This can be used for invalidating and refetching queries after mutations or even optimistic updates."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"useMutation({\n  mutationFn: addTodo,\n  onMutate: (variables) => {\n    // A mutation is about to happen!\n\n    // Optionally return a context containing data to use when for example rolling back\n    return { id: 1 }\n  },\n  onError: (error, variables, context) => {\n    // An error happened!\n    console.log(`rolling back optimistic update with id ${context.id}`)\n  },\n  onSuccess: (data, variables, context) => {\n    // Boom baby!\n  },\n  onSettled: (data, error, variables, context) => {\n    // Error or success... doesn't matter!\n  },\n})\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If you are returning a promise in any of the callback functions, they will wait for the previous one to finish."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'useMutation({\n  mutationFn: addTodo,\n  onSuccess: async () => {\n    console.log("I\'m first!")\n  },\n  onSettled: async () => {\n    console.log("I\'m second!")\n  },\n})\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["You can also trigger additional callbacks using the ",(0,s.jsx)(n.code,{children:"onSuccess"}),", ",(0,s.jsx)(n.code,{children:"onError"}),", and ",(0,s.jsx)(n.code,{children:"onSettled"}),". These callbacks will not run if the component unmounts before the mutation finishes."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"useMutation({\n  mutationFn: addTodo,\n  onSuccess: (data, variables, context) => {\n    // I will fire first\n  },\n  onError: (error, variables, context) => {\n    // I will fire first\n  },\n  onSettled: (data, error, variables, context) => {\n    // I will fire first\n  },\n})\n\nmutate(todo, {\n  onSuccess: (data, variables, context) => {\n    // I will fire second!\n  },\n  onError: (error, variables, context) => {\n    // I will fire second!\n  },\n  onSettled: (data, error, variables, context) => {\n    // I will fire second!\n  },\n})\n"})}),"\n",(0,s.jsx)(n.h4,{id:"consecutive-mutations",children:"Consecutive Mutations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["There is a difference between the ",(0,s.jsx)(n.code,{children:"onSuccess"}),", ",(0,s.jsx)(n.code,{children:"onError"}),", and ",(0,s.jsx)(n.code,{children:"onSettled"})," callbacks when mutations are consecutive."]}),"\n",(0,s.jsx)(n.li,{children:"When passed to the mutate function, the will be fired up once and only if the component is mounted."}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"useMutation"})," function will execute for each mutate call."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"useMutation({\n  mutationFn: addTodo,\n  onSuccess: (data, variables, context) => {\n    // Will be called 3 times\n  },\n})\n\nconst todos = ['Todo 1', 'Todo 2', 'Todo 3']\ntodos.forEach((todo) => {\n  mutate(todo, {\n    onSuccess: (data, variables, context) => {\n      // Will execute only once, for the last mutation (Todo 3),\n      // regardless which mutation resolves first\n    },\n  })\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"promises",children:"Promises"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"mutateAsync"})," instead of ",(0,s.jsx)(n.code,{children:"mutate"})," to get a promise will resolve on success or throw an error."]}),"\n",(0,s.jsx)(n.li,{children:"This can be used to compose side effects."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const mutation = useMutation({ mutationFn: addTodo })\n\ntry {\n  const todo = await mutation.mutateAsync(todo)\n  console.log(todo)\n} catch (error) {\n  console.error(error)\n} finally {\n  console.log('done')\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"retry",children:"Retry"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["By default, mutations are not retried, but is possible with the ",(0,s.jsx)(n.code,{children:"retry"})," function."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const mutation = useMutation({\n  mutationFn: addTodo,\n  retry: 3,\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"persist-mutations",children:"Persist Mutations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Mutations can be persisted to storage if needed and resumed later on."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const queryClient = new QueryClient()\n\n// Define the \"addTodo\" mutation\nqueryClient.setMutationDefaults(['addTodo'], {\n  mutationFn: addTodo,\n  onMutate: async (variables) => {\n    // Cancel current queries for the todos list\n    await queryClient.cancelQueries({ queryKey: ['todos'] })\n\n    // Create optimistic todo\n    const optimisticTodo = { id: uuid(), title: variables.title }\n\n    // Add optimistic todo to todos list\n    queryClient.setQueryData(['todos'], (old) => [...old, optimisticTodo])\n\n    // Return context with the optimistic todo\n    return { optimisticTodo }\n  },\n  onSuccess: (result, variables, context) => {\n    // Replace optimistic todo in the todos list with the result\n    queryClient.setQueryData(['todos'], (old) =>\n      old.map((todo) =>\n        todo.id === context.optimisticTodo.id ? result : todo,\n      ),\n    )\n  },\n  onError: (error, variables, context) => {\n    // Remove optimistic todo from the todos list\n    queryClient.setQueryData(['todos'], (old) =>\n      old.filter((todo) => todo.id !== context.optimisticTodo.id),\n    )\n  },\n  retry: 3,\n})\n\n// Start mutation in some component:\nconst mutation = useMutation({ mutationKey: ['addTodo'] })\nmutation.mutate({ title: 'title' })\n\n// If the mutation has been paused because the device is for example offline,\n// Then the paused mutation can be dehydrated when the application quits:\nconst state = dehydrate(queryClient)\n\n// The mutation can then be hydrated again when the application is started:\nhydrate(queryClient, state)\n\n// Resume the paused mutations:\nqueryClient.resumePausedMutations()\n"})}),"\n",(0,s.jsx)(n.h4,{id:"persisting-offline-mutations",children:"Persisting Offline Mutations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["You can persist offline mutations using the ",(0,s.jsx)(n.code,{children:"persistQueryClient"})," plugin."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const persister = createSyncStoragePersister({\n  storage: window.localStorage,\n})\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n\n// we need a default mutation function so that paused mutations can resume after a page reload\nqueryClient.setMutationDefaults(['todos'], {\n  mutationFn: ({ id, data }) => {\n    return api.updateTodo(id, data)\n  },\n})\n\nexport default function App() {\n  return (\n    <PersistQueryClientProvider\n      client={queryClient}\n      persistOptions={{ persister }}\n      onSuccess={() => {\n        // resume mutations after initial restore from localStorage was successful\n        queryClient.resumePausedMutations()\n      }}\n    >\n      <RestOfTheApp />\n    </PersistQueryClientProvider>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"mutation-scopes",children:"Mutation Scopes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["By default, mutations run in parallel. Even if you run ",(0,s.jsx)(n.code,{children:".mutate()"})," of the same mutation multiple times."]}),"\n",(0,s.jsx)(n.li,{children:"Mutations can be given a scope with an id to avoid it."}),"\n",(0,s.jsxs)(n.li,{children:["All mutations with the same ",(0,s.jsx)(n.code,{children:"scope.id"})," will run in serial, which means they will start in a paused state if there is already a mutation in progress."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const mutation = useMutation({\n  mutationFn: addTodo,\n  scope: {\n    id: 'todo',\n  },\n})\n"})}),"\n",(0,s.jsx)(n.h2,{id:"query-invalidation",children:"Query Invalidation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Waiting for queries to become stale doesn't always work, especially if the user does an action that changes the data."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"QueryClient"})," has an ",(0,s.jsx)(n.code,{children:"invalidateQueries"})," method that lets you intelligently mark queries as stale and fetch them."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Invalidate every query in the cache\nqueryClient.invalidateQueries()\n// Invalidate every query with a key that starts with `todos`\nqueryClient.invalidateQueries({ queryKey: ['todos'] })\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When a query is invalidated, two things can happen:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["It is marked as stale and overrides the ",(0,s.jsx)(n.code,{children:"staleTime"})," configurations being used in ",(0,s.jsx)(n.code,{children:"useQuery"})," or related hooks."]}),"\n",(0,s.jsxs)(n.li,{children:["The query currently being rendered via ",(0,s.jsx)(n.code,{children:"useQuery"})," or related hooks, it will be re-fetched in the background."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"query-matching-with-invalidatequeries",children:["Query Matching with ",(0,s.jsx)(n.code,{children:"invalidateQueries"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When using APIs like ",(0,s.jsx)(n.code,{children:"invalidateQueries"})," and ",(0,s.jsx)(n.code,{children:"removeQueries"}),", you can match queries using their prefix, or get specific and match the exact query."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useQuery, useQueryClient } from '@tanstack/react-query'\n\n// Get QueryClient from the context\nconst queryClient = useQueryClient()\n\nqueryClient.invalidateQueries({ queryKey: ['todos'] })\n\n// Both queries below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { page: 1 }],\n  queryFn: fetchTodoList,\n})\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["You can also invalidate queries with specific variables by passing a specific query to the ",(0,s.jsx)(n.code,{children:"invalidateQueries"})," method."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"queryClient.invalidateQueries({\n  queryKey: ['todos', { type: 'done' }],\n})\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { type: 'done' }],\n  queryFn: fetchTodoList,\n})\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you want to only invalidate ",(0,s.jsx)(n.code,{children:"todos"})," queries that don't have any more variables or sub-keys, you can pass an ",(0,s.jsx)(n.code,{children:"exact: true"})," option to the ",(0,s.jsx)(n.code,{children:"invalidateQueries"})," method:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"queryClient.invalidateQueries({\n  queryKey: ['todos'],\n  exact: true,\n})\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { type: 'done' }],\n  queryFn: fetchTodoList,\n})\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you want more granularity, you can pass a predicate function to the ",(0,s.jsx)(n.code,{children:"invalidateQueries"})," method."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"queryClient.invalidateQueries({\n  predicate: (query) =>\n    query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,\n})\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { version: 20 }],\n  queryFn: fetchTodoList,\n})\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { version: 10 }],\n  queryFn: fetchTodoList,\n})\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { version: 5 }],\n  queryFn: fetchTodoList,\n})\n"})}),"\n",(0,s.jsx)(n.h2,{id:"invalidations-from-mutations",children:"Invalidations from Mutations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When a mutation succeeds in your application, you may need to invalidate other queries and possibly refetch them to account for the new changes."}),"\n",(0,s.jsx)(n.li,{children:"Assume a todo is mutated:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const mutation = useMutation({ mutationFn: postTodo })\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When a successful ",(0,s.jsx)(n.code,{children:"postTodo"})," mutation happens, all todo queries should be invalidated:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useMutation, useQueryClient } from '@tanstack/react-query'\n\nconst queryClient = useQueryClient()\n\n// When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  onSuccess: () => {\n    queryClient.invalidateQueries({ queryKey: ['todos'] })\n    queryClient.invalidateQueries({ queryKey: ['reminders'] })\n  },\n})\n"})}),"\n",(0,s.jsx)(n.h2,{id:"updates-from-mutation-responses",children:"Updates from Mutation Responses"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When doing mutations that update objects on the server, it is common for the new object to be returned in response."}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Instead of refetching any queries for that item, we can use the object returned by the mutation and update the query immediately using the Object Client's ",(0,s.jsx)(n.code,{children:"setQueryData"})," method:"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const queryClient = useQueryClient()\n\nconst mutation = useMutation({\n  mutationFn: editTodo,\n  onSuccess: (data) => {\n    queryClient.setQueryData(['todo', { id: 5 }], data)\n  },\n})\n\nmutation.mutate({\n  id: 5,\n  name: 'Do the laundry',\n})\n\n// The query below will be updated with the response from the\n// successful mutation\nconst { status, data, error } = useQuery({\n  queryKey: ['todo', { id: 5 }],\n  queryFn: fetchTodoById,\n})\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["You can even use the ",(0,s.jsx)(n.code,{children:"onSuccess"})," logic and make a custom hook:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const useMutateTodo = () => {\n  const queryClient = useQueryClient()\n\n  return useMutation({\n    mutationFn: editTodo,\n    // Notice the second argument is the variables object that the `mutate` function receives\n    onSuccess: (data, variables) => {\n      queryClient.setQueryData(['todo', { id: variables.id }], data)\n    },\n  })\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"immutability",children:"Immutability"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Updates via ",(0,s.jsx)(n.code,{children:"setQueryData"})," must be performed in an immutable way."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"queryClient.setQueryData(['posts', { id }], (oldData) => {\n  if (oldData) {\n    // \u274c do not try this\n    oldData.title = 'my new post title'\n  }\n  return oldData\n})\n\nqueryClient.setQueryData(\n  ['posts', { id }],\n  // \u2705 this is the way\n  (oldData) =>\n    oldData\n      ? {\n          ...oldData,\n          title: 'my new post title',\n        }\n      : oldData,\n)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"optimistic-updates",children:"Optimistic Updates"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"There are two ways to optimistically update your UI before a mutation is complete."}),"\n",(0,s.jsxs)(n.li,{children:["You can use the ",(0,s.jsx)(n.code,{children:"onMutate"})," option to update the cache directly, or leverage the returned variables to update your UI."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"via-the-ui",children:"Via the UI"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const addTodoMutation = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  // make sure to _return_ the Promise from the query invalidation\n  // so that the mutation stays in `pending` state until the refetch is finished\n  onSettled: async () => {\n    return await queryClient.invalidateQueries({ queryKey: ['todos'] })\n  },\n})\n\nconst { isPending, submittedAt, variables, mutate, isError } = addTodoMutation\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["This will give you access to the ",(0,s.jsx)(n.code,{children:"addTodoMutation.variables"}),", which contains the added todo."]}),"\n",(0,s.jsx)(n.li,{children:"You can then add the item to the list while it is pending:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"<ul>\n  {todoQuery.items.map((todo) => (\n    <li key={todo.id}>{todo.text}</li>\n  ))}\n  {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}\n</ul>\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If the mutation errors out, the object will disappear. If you still want it to be shown, you can check the ",(0,s.jsx)(n.code,{children:"isError"})," state."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"variables"})," are not cleared if the mutation fails, so they can still be accessed."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"{\n  isError && (\n    <li style={{ color: 'red' }}>\n      {variables}\n      <button onClick={() => mutate(variables)}>Retry</button>\n    </li>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"if-the-mutation-and-the-query-do-not-live-in-the-same-component",children:"If the mutation and the query do not live in the same component."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The approach still works if the mutation and query do not live in the same component."}),"\n",(0,s.jsxs)(n.li,{children:["You can get access to all other mutations in other components using the dedicated ",(0,s.jsx)(n.code,{children:"useMutationState"})," hook, which should be combined to the ",(0,s.jsx)(n.code,{children:"mutationKey"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// somewhere in your app\nconst { mutate } = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n  mutationKey: ['addTodo'],\n})\n\n// access variables somewhere else\nconst variables = useMutationState<string>({\n  filters: { mutationKey: ['addTodo'], status: 'pending' },\n  select: (mutation) => mutation.state.variables,\n})\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"variables"})," will be an array, because there can be multiple mutations at the same time."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"via-the-cache",children:"Via the Cache"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If a mutation fails and you cannot refetch your query, you can roll back your update."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useMutation"}),"'s ",(0,s.jsx)(n.code,{children:"onMutate"})," handler options allows you to return a value that will be passed onto both ",(0,s.jsx)(n.code,{children:"onError"})," and ",(0,s.jsx)(n.code,{children:"onSettled"})," handlers as the last argument."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"updating-a-list-of-todos-when-adding-a-new-todo",children:"Updating a list of todos when adding a new todo"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const queryClient = useQueryClient()\n\nuseMutation({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo) => {\n    // Cancel any outgoing re-fetches\n    // (so they don't overwrite our optimistic update)\n    await queryClient.cancelQueries({ queryKey: ['todos'] })\n\n    // Snapshot the previous value\n    const previousTodos = queryClient.getQueryData(['todos'])\n\n    // Optimistically update to the new value\n    queryClient.setQueryData(['todos'], (old) => [...old, newTodo])\n\n    // Return a context object with the snapshotted value\n    return { previousTodos }\n  },\n  // If the mutation fails,\n  // use the context returned from onMutate to roll back\n  onError: (err, newTodo, context) => {\n    queryClient.setQueryData(['todos'], context.previousTodos)\n  },\n  // Always refetch after error or success:\n  onSettled: () => {\n    queryClient.invalidateQueries({ queryKey: ['todos'] })\n  },\n})\n"})}),"\n",(0,s.jsx)(n.h4,{id:"updating-a-single-todo",children:"Updating a single Todo"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"useMutation({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await queryClient.cancelQueries({ queryKey: ['todos', newTodo.id] })\n\n    // Snapshot the previous value\n    const previousTodo = queryClient.getQueryData(['todos', newTodo.id])\n\n    // Optimistically update to the new value\n    queryClient.setQueryData(['todos', newTodo.id], newTodo)\n\n    // Return a context with the previous and new todo\n    return { previousTodo, newTodo }\n  },\n  // If the mutation fails, use the context we returned above\n  onError: (err, newTodo, context) => {\n    queryClient.setQueryData(\n      ['todos', context.newTodo.id],\n      context.previousTodo,\n    )\n  },\n  // Always refetch after error or success:\n  onSettled: (newTodo) => {\n    queryClient.invalidateQueries({ queryKey: ['todos', newTodo.id] })\n  },\n})\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["You can also use an ",(0,s.jsx)(n.code,{children:"onSettled"})," function in place of a separate ",(0,s.jsx)(n.code,{children:"onError"})," and ",(0,s.jsx)(n.code,{children:"onSuccess"})," handlers:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"useMutation({\n  mutationFn: updateTodo,\n  // ...\n  onSettled: (newTodo, error, variables, context) => {\n    if (error) {\n      // do something\n    }\n  },\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"when-to-use-what",children:"When to use what"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you only have one place where the optimistic result should be shown, use the ",(0,s.jsx)(n.code,{children:"variables"})," approach."]}),"\n",(0,s.jsx)(n.li,{children:"If you have multiple places where the update needs to be known, the manipulating the cache will take care of this for you automatically."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"query-cancellation",children:"Query Cancellation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Each query has an ",(0,s.jsx)(n.code,{children:"AbortSignal"})," instance. When a query becomes out-of-date or inactive, the ",(0,s.jsx)(n.code,{children:"signal"})," will become aborted."]}),"\n",(0,s.jsx)(n.li,{children:"You can respond to a cancelled query if desired."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"default-behavior",children:"Default Behavior"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Queries that unmount or become unused before their promises are resolved are not cancelled."}),"\n",(0,s.jsx)(n.li,{children:"After it resolves, the data will become available in the cache."}),"\n",(0,s.jsx)(n.li,{children:"If you mount the component again, the data will be available."}),"\n",(0,s.jsxs)(n.li,{children:["If you consume the ",(0,s.jsx)(n.code,{children:"AbortSignal"}),", the promise is cancelled and the query is cancelled. The state will revert to the previous state."]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"using-fetch",children:["Using ",(0,s.jsx)(n.code,{children:"fetch"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const query = useQuery({\n  queryKey: ['todos'],\n  queryFn: async ({ signal }) => {\n    const todosResponse = await fetch('/todos', {\n      // Pass the signal to one fetch\n      signal,\n    })\n    const todos = await todosResponse.json()\n\n    const todoDetails = todos.map(async ({ details }) => {\n      const response = await fetch(details, {\n        // Or pass it to several\n        signal,\n      })\n      return response.json()\n    })\n\n    return Promise.all(todoDetails)\n  },\n})\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"using-axios-v0220",children:["Using ",(0,s.jsx)(n.code,{children:"axios"})," v0.22.0+"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import axios from 'axios'\n\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) =>\n    axios.get('/todos', {\n      // Pass the signal to `axios`\n      signal,\n    }),\n})\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"using-axios-with-version-lower-than-v0220",children:["Using ",(0,s.jsx)(n.code,{children:"axios"})," with version lower than ",(0,s.jsx)(n.code,{children:"v0.22.0"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import axios from 'axios'\n\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    // Create a new CancelToken source for this request\n    const CancelToken = axios.CancelToken\n    const source = CancelToken.source()\n\n    const promise = axios.get('/todos', {\n      // Pass the source token to your request\n      cancelToken: source.token,\n    })\n\n    // Cancel the request if TanStack Query signals to abort\n    signal?.addEventListener('abort', () => {\n      source.cancel('Query was cancelled by TanStack Query')\n    })\n\n    return promise\n  },\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"manual-cancellation",children:"Manual Cancellation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you want to cancel a request manually, you can call ",(0,s.jsx)(n.code,{children:"queryClient.cancelQueries({queryKey})"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const query = useQuery({\n  queryKey: ['todos'],\n  queryFn: async ({ signal }) => {\n    const resp = await fetch('/todos', { signal })\n    return resp.json()\n  },\n})\n\nconst queryClient = useQueryClient()\n\nreturn (\n  <button\n    onClick={(e) => {\n      e.preventDefault()\n      queryClient.cancelQueries({ queryKey: ['todos'] })\n    }}\n  >\n    Cancel\n  </button>\n)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When using suspense mode, cancellation does not work."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Writing tests for TanStack query can be done using the ",(0,s.jsx)(n.a,{href:"https://react-hooks-testing-library.com/",children:"React Hooks Testing Library"})]}),"\n",(0,s.jsx)(n.li,{children:"To install:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install @testing-library/react-hooks react-test-renderer --save-dev\n"})}),"\n",(0,s.jsx)(n.h3,{id:"our-first-test",children:"Our First Test"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Once installed, here is a simple test:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"export function useCustomHook() {\n  return useQuery({ queryKey: ['customHook'], queryFn: () => 'Hello' })\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Using React 17 or earlier:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const queryClient = new QueryClient()\nconst wrapper = ({ children }) => (\n  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n)\n\nconst { result, waitFor } = renderHook(() => useCustomHook(), { wrapper })\n\nawait waitFor(() => result.current.isSuccess)\n\nexpect(result.current.data).toEqual('Hello')\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Using React 18 or later:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { renderHook, waitFor } from "@testing-library/react";\n\n...\n\nconst { result } = renderHook(() => useCustomHook(), { wrapper });\n\nawait waitFor(() => expect(result.current.isSuccess).toBe(true));\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"By providing a custom wrapper, the test remains isolated from the other tests."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"turn-off-retries",children:"Turn off Retries"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Best way to turn off retries during tests is in the ",(0,s.jsx)(n.code,{children:"QueryClientProvider"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      // \u2705 turns retries off\n      retry: false,\n    },\n  },\n})\nconst wrapper = ({ children }) => (\n  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setting-gctime-to-infinity-with-jest",children:"Setting gcTime to Infinity with Jest"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Set the gcTime to infinity to prevent ",(0,s.jsx)(n.code,{children:"Jest did not exit one second after the test run completed"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"testing-network-calls",children:"Testing Network Calls"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/nock",children:"Nock"})," can be used to test if TanStack is making the correct network requests."]}),"\n",(0,s.jsx)(n.li,{children:"For this hook:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function useFetchData() {\n  return useQuery({\n    queryKey: ['fetchData'],\n    queryFn: () => request('/api/data'),\n  })\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"We can write this test:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const queryClient = new QueryClient()\nconst wrapper = ({ children }) => (\n  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n)\n\nconst expectation = nock('http://example.com').get('/api/data').reply(200, {\n  answer: 42,\n})\n\nconst { result, waitFor } = renderHook(() => useFetchData(), { wrapper })\n\nawait waitFor(() => {\n  return result.current.isSuccess\n})\n\nexpect(result.current.data).toEqual({ answer: 42 })\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);