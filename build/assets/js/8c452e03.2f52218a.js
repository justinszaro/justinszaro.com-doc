"use strict";(self.webpackChunkjustinszarodotcom_doscs=self.webpackChunkjustinszarodotcom_doscs||[]).push([[825],{6853:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"technologies/React/Packages/TanStackQuery/guides-and-concepts","title":"TanStackQuery Guides and Concepts","description":"Important Defaults","source":"@site/docs/technologies/React/Packages/TanStackQuery/guides-and-concepts.md","sourceDirName":"technologies/React/Packages/TanStackQuery","slug":"/technologies/React/Packages/TanStackQuery/guides-and-concepts","permalink":"/docs/technologies/React/Packages/TanStackQuery/guides-and-concepts","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"technologies","previous":{"title":"TanStackQuery","permalink":"/docs/technologies/React/Packages/TanStackQuery/getting-started"},"next":{"title":"react-intro","permalink":"/docs/technologies/React/react-intro"}}');var t=i(4848),a=i(8453);const r={},l="TanStackQuery Guides and Concepts",d={},o=[{value:"Important Defaults",id:"important-defaults",level:2},{value:"Queries",id:"queries",level:2},{value:"Query Basics",id:"query-basics",level:3},{value:"Fetch Status",id:"fetch-status",level:4},{value:"Why two different states?",id:"why-two-different-states",level:4},{value:"Query Keys",id:"query-keys",level:2},{value:"Simple Query Keys",id:"simple-query-keys",level:3},{value:"Array Key with Variables",id:"array-key-with-variables",level:3},{value:"Query Keys are hashed deterministically!!!",id:"query-keys-are-hashed-deterministically",level:3},{value:"If your query function depends on variables, include it in your query key.",id:"if-your-query-function-depends-on-variables-include-it-in-your-query-key",level:3},{value:"Query Functions",id:"query-functions",level:2},{value:"Handling and Throwing Errors",id:"handling-and-throwing-errors",level:4},{value:"Using With <code>fetch</code> and other clients that do not throw by default.",id:"using-with-fetch-and-other-clients-that-do-not-throw-by-default",level:4},{value:"Query Function Variables",id:"query-function-variables",level:4},{value:"QueryFunctionContext",id:"queryfunctioncontext",level:4},{value:"Query Options",id:"query-options",level:2},{value:"Network Mode",id:"network-mode",level:2},{value:"Network Mode: online (Default)",id:"network-mode-online-default",level:3},{value:"Network Mode: always",id:"network-mode-always",level:4},{value:"Network Mode: offlineFirst",id:"network-mode-offlinefirst",level:4},{value:"Parallel Queries",id:"parallel-queries",level:2},{value:"Manual Parallel Queries",id:"manual-parallel-queries",level:3},{value:"Dynamic Parallel Queries use <code>useQueries</code>",id:"dynamic-parallel-queries-use-usequeries",level:3},{value:"Dependent Queries",id:"dependent-queries",level:2},{value:"<code>useQueries</code> dependent Query",id:"usequeries-dependent-query",level:3},{value:"A note about performance:",id:"a-note-about-performance",level:3},{value:"Background Fetching Indicators",id:"background-fetching-indicators",level:2},{value:"Displaying the Global Background Fetching Loading State",id:"displaying-the-global-background-fetching-loading-state",level:3},{value:"Window Focus Refetching",id:"window-focus-refetching",level:2},{value:"Custom Window Focus Event",id:"custom-window-focus-event",level:3},{value:"Managing Focus in React Native",id:"managing-focus-in-react-native",level:3},{value:"Managing Focus State",id:"managing-focus-state",level:3},{value:"Disabling and Pausing Queries",id:"disabling-and-pausing-queries",level:2},{value:"Lazy Queries",id:"lazy-queries",level:3},{value:"isLoading (Previously: <code>isInitialLoading</code>)",id:"isloading-previously-isinitialloading",level:3},{value:"Query Retries",id:"query-retries",level:2},{value:"Retry Delay",id:"retry-delay",level:3},{value:"Paginated / Lagged Queries",id:"paginated--lagged-queries",level:2},{value:"Better Paginated Queries with <code>placeholderData</code>",id:"better-paginated-queries-with-placeholderdata",level:3},{value:"Lagging Infinite Query results with <code>placeholderData</code>",id:"lagging-infinite-query-results-with-placeholderdata",level:3},{value:"Infinite Queries",id:"infinite-queries",level:2},{value:"What happens when an infinite query needs to be re-fetched?",id:"what-happens-when-an-infinite-query-needs-to-be-re-fetched",level:3},{value:"What if I want to implement a bi-directional infinite list?",id:"what-if-i-want-to-implement-a-bi-directional-infinite-list",level:3},{value:"What if I want to show the pages in reverse order?",id:"what-if-i-want-to-show-the-pages-in-reverse-order",level:3},{value:"What if I want to manually update the infinite query?",id:"what-if-i-want-to-manually-update-the-infinite-query",level:3},{value:"Manually removing first page:",id:"manually-removing-first-page",level:4},{value:"Manually removing a single value from an individual page:",id:"manually-removing-a-single-value-from-an-individual-page",level:4},{value:"Keep only the first page:",id:"keep-only-the-first-page",level:4},{value:"What if I want limit the number of pages?",id:"what-if-i-want-limit-the-number-of-pages",level:3},{value:"What if my API doesn&#39;t return a cursor?",id:"what-if-my-api-doesnt-return-a-cursor",level:3},{value:"Initial Query Data",id:"initial-query-data",level:2},{value:"Using <code>initialData</code> to pre-populate a query",id:"using-initialdata-to-pre-populate-a-query",level:3},{value:"<code>stateTime</code> and <code>initialDataUpdatedAt</code>",id:"statetime-and-initialdataupdatedat",level:3},{value:"Initial Data Function",id:"initial-data-function",level:3},{value:"Initial Data from Cache",id:"initial-data-from-cache",level:3},{value:"Initial Data from the cache with <code>initialDataUpdatedAt</code>",id:"initial-data-from-the-cache-with-initialdataupdatedat",level:3},{value:"Conditional Initial Data from Cache",id:"conditional-initial-data-from-cache",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"tanstackquery-guides-and-concepts",children:"TanStackQuery Guides and Concepts"})}),"\n",(0,t.jsx)(n.h2,{id:"important-defaults",children:"Important Defaults"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Out of box, TanStack Query is configured with aggressive but sane defaults."}),"\n",(0,t.jsxs)(n.li,{children:["The following is good to keep in mind when debugging/learning.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Query instances via ",(0,t.jsx)(n.code,{children:"useQuery"})," or ",(0,t.jsx)(n.code,{children:"useInfiniteQuery"})," by default consider cached data as stale.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["To change, you con configure globally or per query using the ",(0,t.jsx)(n.code,{children:"staleTime"})," option."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Stale queries are re-fetched automatically in the background when","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"New instances of the query mount"}),"\n",(0,t.jsx)(n.li,{children:"The window is refocused."}),"\n",(0,t.jsx)(n.li,{children:"The network is reconnected."}),"\n",(0,t.jsx)(n.li,{children:"The query is optionally configured with a refresh interval."}),"\n",(0,t.jsxs)(n.li,{children:["To change, you can use the following options:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"refetchOnMount"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"refetchOnWindowFocus"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"refetchOnReconnect"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"refetchInterval"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Query results have that have no more active instances of ",(0,t.jsx)(n.code,{children:"useQuery"}),", ",(0,t.jsx)(n.code,{children:"useInfiniteQuery"}),', or query observers are labeled as "inactive" and remain in the cache in case they are used again at a later time.']}),"\n",(0,t.jsxs)(n.li,{children:['By default, "inactive" queries are garbage collected after 5 minutes.',"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["To change, you can alter ",(0,t.jsx)(n.code,{children:"gcTime"})," for something other than 1000 _ 60 _ 5 milliseconds."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Queries that fail are silently retried 3 times with exponential backoff delay before being captured an sent to the UI.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["To change: you can alter ",(0,t.jsx)(n.code,{children:"retry"})," and ",(0,t.jsx)(n.code,{children:"retryDelay"})," options for queries to something other than the defaults."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Query results by default are structurally shared to detect if data has actually changed and if not, the data reference remains unchanged to better help with value stabilization with regards to useMemo and useCallback.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"99.9% of the time, this isn't an issue."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"queries",children:"Queries"}),"\n",(0,t.jsx)(n.h3,{id:"query-basics",children:"Query Basics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A query is a declarative dependency on an asynchronous source of data that is tied to a unique key."}),"\n",(0,t.jsx)(n.li,{children:"Queries can be used with any promise based method (including GET and POST api calls) to fetch data from a server. If the method modifies the data, it is recommended to use Mutations instead."}),"\n",(0,t.jsxs)(n.li,{children:["To subscribe to a query in a component or custom hook, use the ",(0,t.jsx)(n.code,{children:"useQuery"})," hook with at least,","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A unique key for the query"}),"\n",(0,t.jsxs)(n.li,{children:["A function that returns a promise that:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Resolves the data, or"}),"\n",(0,t.jsx)(n.li,{children:"Throws an error."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import { useQuery } from "@tanstack/react-query";\n\nfunction App() {\n  const info = useQuery({ queryKey: ["todos"], queryFn: fetchTodoList });\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The unique key provided is used internally for refetching, caching, and sharing queries through the application."}),"\n",(0,t.jsxs)(n.li,{children:["The query result returned by ",(0,t.jsx)(n.code,{children:"useQuery"})," contains all the information about the query that is needed for templating or any other data usage."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'const result = useQuery({ queryKey: ["todos"], queryFn: fetchTodoList });\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The result object contains a few different states:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"isPending"})," or ",(0,t.jsx)(n.code,{children:"status == 'pending'"})," - The query has no data yet."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"isError"})," or ",(0,t.jsx)(n.code,{children:"status == 'error'"})," - The query encountered an error."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"isSuccess"})," or ",(0,t.jsx)(n.code,{children:"status == 'success'"})," - The query was successful and data is available."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Beyond the states, more information is available depending on the states:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"error"})," - If the query errored, the error is available on the ",(0,t.jsx)(n.code,{children:"error"})," property."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data"})," - If the query is successful, the data is available on the ",(0,t.jsx)(n.code,{children:"data"})," property."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"isFetching"})," - In any state, if the query is fetching at any time (including background refetching) ",(0,t.jsx)(n.code,{children:"isFetching"})," will be true."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["For most queries, it is usually sufficient to check for the ",(0,t.jsx)(n.code,{children:"isPending"})," state, then the ",(0,t.jsx)(n.code,{children:"isError"})," state, then finally assume that the data is available and render the successful state."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'function Todos() {\n  const { isPending, isError, data, error } = useQuery({\n    queryKey: ["todos"],\n    queryFn: fetchTodoList,\n  });\n\n  if (isPending) {\n    return <span>Loading...</span>;\n  }\n\n  if (isError) {\n    return <span>Error: {error.message}</span>;\n  }\n\n  // We can assume by this point that `isSuccess === true`\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  );\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"or, if you don't prefer booleans"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'function Todos() {\n  const { status, data, error } = useQuery({\n    queryKey: ["todos"],\n    queryFn: fetchTodoList,\n  });\n\n  if (status === "pending") {\n    return <span>Loading...</span>;\n  }\n\n  if (status === "error") {\n    return <span>Error: {error.message}</span>;\n  }\n\n  // also status === \'success\', but "else" logic works, too\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  );\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"fetch-status",children:"Fetch Status"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["In addition to the status field, you will also get an additional ",(0,t.jsx)(n.code,{children:"fetchStatus"})," property with the following options","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"fetchStatus == 'pending'"})," - The query is currently fetching."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"fetchStatus == 'pausing'"})," - The query wanted to fetch, but is paused. (See Network Mode)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"fetchStatus == 'idle'"})," - The query isn't doing anything."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"why-two-different-states",children:"Why two different states?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Background re-fetches and stale-while-revalidate logic make all combinations for status and fetchStatus possible."}),"\n",(0,t.jsxs)(n.li,{children:["A query can be in a ",(0,t.jsx)(n.code,{children:"pending"})," state without fetching any data. Keep in mind:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"status"})," gives information about the data (Is there any?)"]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"fetchStatus"})," gives information about the ",(0,t.jsx)(n.code,{children:"queryFn"})," (Is it running?)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"query-keys",children:"Query Keys"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"At its core, TanStack query manages query caching based on the several query keys."}),"\n",(0,t.jsx)(n.li,{children:"At the top level they are an array, but can be as simple as an Array with a single string and as complex as an array of many strings and other nested objects."}),"\n",(0,t.jsx)(n.li,{children:"As long as the query key is serializable and unique, it can be used!"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"simple-query-keys",children:"Simple Query Keys"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The simplest form of a key is an array with constant values, which is useful for","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Generic List/Index resources"}),"\n",(0,t.jsx)(n.li,{children:"Non-Hierarchical resources"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"// A list of todos\nuseQuery({ queryKey: ['todos'], ... })\n\n// Something else, whatever!\nuseQuery({ queryKey: ['something', 'special'], ... })\n"})}),"\n",(0,t.jsx)(n.h3,{id:"array-key-with-variables",children:"Array Key with Variables"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When a query needs to describe its data, you can use an array with a string and any serializable objects to describe it."}),"\n",(0,t.jsxs)(n.li,{children:["This is useful for","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Hierarchical or nested resources","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It is common to pass an id, index, or other primitive to uniquely identify the item."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Queries with additional parameters/","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It is common to pass an object of additional options."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"// An individual todo\nuseQuery({ queryKey: ['todo', 5], ... })\n\n// An individual todo in a \"preview\" format\nuseQuery({ queryKey: ['todo', 5, { preview: true }], ...})\n\n// A list of todos that are \"done\"\nuseQuery({ queryKey: ['todos', { type: 'done' }], ... })\n"})}),"\n",(0,t.jsx)(n.h3,{id:"query-keys-are-hashed-deterministically",children:"Query Keys are hashed deterministically!!!"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No matter the order of keys in objects, the following queries are considered equally."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"useQuery({ queryKey: ['todos', { status, page }], ... })\nuseQuery({ queryKey: ['todos', { page, status }], ...})\nuseQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The following query keys are not equal, since array order matters."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"useQuery({ queryKey: ['todos', status, page], ... })\nuseQuery({ queryKey: ['todos', page, status], ...})\nuseQuery({ queryKey: ['todos', undefined, page, status], ...})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"if-your-query-function-depends-on-variables-include-it-in-your-query-key",children:"If your query function depends on variables, include it in your query key."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Since query keys described the data they are fetching, they should include any variations in your query function that change."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'function Todos({ todoId }) {\n  const result = useQuery({\n    queryKey: ["todos", todoId],\n    queryFn: () => fetchTodoById(todoId),\n  });\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Query Keys act as dependencies for your function."}),"\n",(0,t.jsx)(n.li,{children:"Adding dependent variables to your query key will ensure that queries are cached independently, and are re-fetched automatically anytime a variable changes."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"query-functions",children:"Query Functions"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A query function is any function that returns a promise. That promise should either resolve the data or throw an error."}),"\n",(0,t.jsx)(n.li,{children:"The following are all valid query configurations:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'useQuery({ queryKey: ["todos"], queryFn: fetchAllTodos });\nuseQuery({ queryKey: ["todos", todoId], queryFn: () => fetchTodoById(todoId) });\nuseQuery({\n  queryKey: ["todos", todoId],\n  queryFn: async () => {\n    const data = await fetchTodoById(todoId);\n    return data;\n  },\n});\nuseQuery({\n  queryKey: ["todos", todoId],\n  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),\n});\n'})}),"\n",(0,t.jsx)(n.h4,{id:"handling-and-throwing-errors",children:"Handling and Throwing Errors"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For TanStack query to determine a query errored, the query function must throw or return a rejected Promise."}),"\n",(0,t.jsx)(n.li,{children:"Any error that is thrown in the query function will be persisted in the error state of the query."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'const { error } = useQuery({\n  queryKey: ["todos", todoId],\n  queryFn: async () => {\n    if (somethingGoesWrong) {\n      throw new Error("Oh no!");\n    }\n    if (somethingElseGoesWrong) {\n      return Promise.reject(new Error("Oh no!"));\n    }\n\n    return data;\n  },\n});\n'})}),"\n",(0,t.jsxs)(n.h4,{id:"using-with-fetch-and-other-clients-that-do-not-throw-by-default",children:["Using With ",(0,t.jsx)(n.code,{children:"fetch"})," and other clients that do not throw by default."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["With most utilities like ",(0,t.jsx)(n.code,{children:"axios"})," and ",(0,t.jsx)(n.code,{children:"graphql-request"})," automatically throw errors for unsuccessful HTTP calls, some utilities like ",(0,t.jsx)(n.code,{children:"fetch"})," don't. In that case, throw them on your own."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'useQuery({\n  queryKey: ["todos", todoId],\n  queryFn: async () => {\n    const response = await fetch("/todos/" + todoId);\n    if (!response.ok) {\n      throw new Error("Network response was not ok");\n    }\n    return response.json();\n  },\n});\n'})}),"\n",(0,t.jsx)(n.h4,{id:"query-function-variables",children:"Query Function Variables"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Query keys are passed into your query function as part of the QueryFunctionContext."}),"\n",(0,t.jsx)(n.li,{children:"With not always needed, it makes it possible to extract your query functions if needed:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"function Todos({ status, page }) {\n  const result = useQuery({\n    queryKey: ['todos', { status, page }],\n    queryFn: fetchTodoList,\n  })\n}\n\n// Access the key, status and page variables in your query function!\nfunction fetchTodoList({ queryKey }) {\n  const [_key, { status, page }] = queryKey\n  return new Promise()\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"queryfunctioncontext",children:"QueryFunctionContext"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The QueryFunctionContext is the object passed to every query function. It consists of","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"queryKey: QueryKey"})," - Query Keys"]}),"\n",(0,t.jsxs)(n.li,{children:["`signal?: Abort Signal","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal",children:"AbortSignal"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"meta: Record<string, unknown> | undefined"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"An optional field that you can fill in additional information about your query."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Infinite Queries get some additional information passed:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"pageParam: tPageParam"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The page parameter used to fetch the current page."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"query-options",children:"Query Options"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["One of the best ways to share ",(0,t.jsx)(n.code,{children:"queryKey"})," and ",(0,t.jsx)(n.code,{children:"queryFn"})," between multiple places is to use the ",(0,t.jsx)(n.code,{children:"queryOptions"})," helper."]}),"\n",(0,t.jsx)(n.li,{children:"At runtime, the helper just returns whatever you pass info it."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import { queryOptions } from "@tanstack/react-query";\n\nfunction groupOptions(id: number) {\n  return queryOptions({\n    queryKey: ["groups", id],\n    queryFn: () => fetchGroups(id),\n    staleTime: 5 * 1000,\n  });\n}\n\n// usage:\n\nuseQuery(groupOptions(1));\nuseSuspenseQuery(groupOptions(5));\nuseQueries({\n  queries: [groupOptions(1), groupOptions(2)],\n});\nqueryClient.prefetchQuery(groupOptions(23));\nqueryClient.setQueryData(groupOptions(42).queryKey, newGroups);\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For infinite queries, a separate ",(0,t.jsx)(n.code,{children:"infiniteQueryOptions"})," helper is available."]}),"\n",(0,t.jsxs)(n.li,{children:["You can still override some options at a component level. A very common and useful pattern is to create per-component ",(0,t.jsx)(n.code,{children:"select"})," functions."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"// Type inference still works, so query.data will be the return type of select instead of queryFn\n\nconst query = useQuery({\n  ...groupOptions(1),\n  select: (data) => data.groupName,\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"network-mode",children:"Network Mode"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"There are three different network modes to distinguish how Queries and Mutations should behave if there is no network connection."}),"\n",(0,t.jsx)(n.li,{children:"They can be set for each individually or globally."}),"\n",(0,t.jsxs)(n.li,{children:["The default network mode is ",(0,t.jsx)(n.code,{children:"online"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"network-mode-online-default",children:"Network Mode: online (Default)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In this mode, queries and mutations will now fire unless you have a network connection."}),"\n",(0,t.jsx)(n.li,{children:"If a fetch is initiated, it was always stay in the state it is in if the fetch cannot be made because there is no network connection."}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"fetchStatus"})," is exposed additionally. It is either:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"fetching"})," - The ",(0,t.jsx)(n.code,{children:"queryFn"})," is really exciting - a request is in-flight."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"paused"})," - The query is not executing - it is ",(0,t.jsx)(n.code,{children:"paused"})," until you have a connection again."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"idle"})," - The query is not fetching and not paused."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["The flags ",(0,t.jsx)(n.code,{children:"isFetching"})," and ",(0,t.jsx)(n.code,{children:"isPaused"})," are derived from this state and exposed for convenience."]}),"\n",(0,t.jsx)(n.li,{children:"If you are online and then go offline while the fetch is occurring, the retry mechanism will be paused. It will resume once you regain internet connection."}),"\n",(0,t.jsx)(n.li,{children:"If the query was cancelled, it will not resume once internet connection is established."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"network-mode-always",children:"Network Mode: always"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"TanStack Query will always ignore the online/offline state. This is better for an environment where you don't need internet connection for the queries to work."}),"\n",(0,t.jsx)(n.li,{children:"Queries will never be paused if there is no internet connection"}),"\n",(0,t.jsx)(n.li,{children:"Retries will not be paused"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"refetchOnConnect"})," defaults to false in this mode."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"network-mode-offlinefirst",children:"Network Mode: offlineFirst"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"This is the middle ground between the three modes."}),"\n",(0,t.jsx)(n.li,{children:"The query will be run once, but all retires will be paused."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"parallel-queries",children:"Parallel Queries"}),"\n",(0,t.jsx)(n.p,{children:"Parallel Queries\n: Queries that are executed in parallel, or at the same time to maximize fetching concurrency."}),"\n",(0,t.jsx)(n.h3,{id:"manual-parallel-queries",children:"Manual Parallel Queries"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["When the number of parallel queries does not change, there is no extra effort needed. Just use any number of ",(0,t.jsx)(n.code,{children:"useQuery"})," or ",(0,t.jsx)(n.code,{children:"useInfiniteQuery"})," hooks side-by-side!"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"function App () {\n  // The following queries will execute in parallel\n  const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })\n  const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })\n  const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })\n  ...\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"This does not work in suspense mode!"}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"dynamic-parallel-queries-use-usequeries",children:["Dynamic Parallel Queries use ",(0,t.jsx)(n.code,{children:"useQueries"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If the number of queries changes depending on the render, you can use the ",(0,t.jsx)(n.code,{children:"useQueries"})," hook."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"useQueries"})," accepts an options object with a query key where the value is an array of query objects. It returns the array of query results."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'function App({ users }) {\n  const userQueries = useQueries({\n    queries: users.map((user) => {\n      return {\n        queryKey: ["user", user.id],\n        queryFn: () => fetchUserById(user.id),\n      };\n    }),\n  });\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"dependent-queries",children:"Dependent Queries"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Dependent (or Serial) queries depend on the previous ones before they can execute."}),"\n",(0,t.jsxs)(n.li,{children:["To do this, you can use the ",(0,t.jsx)(n.code,{children:"enabled"})," option to tell a query when it is ready to run."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'// Get the user\nconst { data: user } = useQuery({\n  queryKey: ["user", email],\n  queryFn: getUserByEmail,\n});\n\nconst userId = user?.id;\n\n// Then get the user\'s projects\nconst {\n  status,\n  fetchStatus,\n  data: projects,\n} = useQuery({\n  queryKey: ["projects", userId],\n  queryFn: getProjectsByUser,\n  // The query will not execute until the userId exists\n  enabled: !!userId,\n});\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"usequeries-dependent-query",children:[(0,t.jsx)(n.code,{children:"useQueries"})," dependent Query"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"useQueries"})," can depend on a previous Query as well:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'// Get the users ids\nconst { data: userIds } = useQuery({\n  queryKey: ["users"],\n  queryFn: getUsersData,\n  select: (users) => users.map((user) => user.id),\n});\n\n// Then get the users messages\nconst usersMessages = useQueries({\n  queries: userIds\n    ? userIds.map((id) => {\n        return {\n          queryKey: ["messages", id],\n          queryFn: () => getMessagesByUsers(id),\n        };\n      })\n    : [], // if users is undefined, an empty array will be returned\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"a-note-about-performance",children:"A note about performance:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Dependent queries produce a request waterfall, which can hurt performance. It is best to flatten the waterfall if possible."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"background-fetching-indicators",children:"Background Fetching Indicators"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A query's ",(0,t.jsx)(n.code,{children:"status === 'pending'"})," is enough to show the hard-loading state for the query."]}),"\n",(0,t.jsx)(n.li,{children:"Sometimes, you may want to show an additional indicator that the query if refetching in the background."}),"\n",(0,t.jsxs)(n.li,{children:["You can do this with the ",(0,t.jsx)(n.code,{children:"isFetching"})," boolean, regardless of the status variable."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'function Todos() {\n  const {\n    status,\n    data: todos,\n    error,\n    isFetching,\n  } = useQuery({\n    queryKey: ["todos"],\n    queryFn: fetchTodos,\n  });\n\n  return status === "pending" ? (\n    <span>Loading...</span>\n  ) : status === "error" ? (\n    <span>Error: {error.message}</span>\n  ) : (\n    <>\n      {isFetching ? <div>Refreshing...</div> : null}\n\n      <div>\n        {todos.map((todo) => (\n          <Todo todo={todo} />\n        ))}\n      </div>\n    </>\n  );\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"displaying-the-global-background-fetching-loading-state",children:"Displaying the Global Background Fetching Loading State"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You can configure a global loading indicator when any queries are fetching (including in the background)."}),"\n",(0,t.jsxs)(n.li,{children:["You use the ",(0,t.jsx)(n.code,{children:"useIsFetching"})," hook."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import { useIsFetching } from "@tanstack/react-query";\n\nfunction GlobalLoadingIndicator() {\n  const isFetching = useIsFetching();\n\n  return isFetching ? (\n    <div>Queries are fetching in the background...</div>\n  ) : null;\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"window-focus-refetching",children:"Window Focus Refetching"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If a user leaves your application and the data goes stale, TanStack Query automatically refreshes the data when the user returns."}),"\n",(0,t.jsx)(n.li,{children:"This can be disabled globally by doing:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      refetchOnWindowFocus: false, // default: true\n    },\n  },\n});\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>;\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"This can be disabled per query by doing:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'useQuery({\n  queryKey: ["todos"],\n  queryFn: fetchTodos,\n  refetchOnWindowFocus: false,\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"custom-window-focus-event",children:"Custom Window Focus Event"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In rare circumstances, you may want to manage your own window focus events that trigger TanStackQuery to revalidate."}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"focusManager.setEventListener"})," is provided tht allows you to add a callback that should be fired when a window is focused."]}),"\n",(0,t.jsx)(n.li,{children:"The following is the default handler:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"focusManager.setEventListener((handleFocus) => {\n  // Listen to visibility change\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    const visibilityChangeHandler = () => {\n      handleFocus(document.visibilityState === 'visible')\n    }\n    window.addEventListener('visibilityChange', visibilityChangeHandler, false)\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener('visibilityChange', visibilityChangeHandler)\n    }\n  }\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"managing-focus-in-react-native",children:"Managing Focus in React Native"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Instead of event listeners on window, React Native provides focus information in the ",(0,t.jsx)(n.code,{children:"AppState"})," module."]}),"\n",(0,t.jsxs)(n.li,{children:["You can use the ",(0,t.jsx)(n.code,{children:"AppState"}),' "change" event to trigger an update when the app state changes back to active.']}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { AppState } from 'react-native'\nimport { focusManager } from '@tanstack/react-query'\n\nfunction onAppStateChange(status: AppStateStatus) {\n  if (Platform.OS !== 'web') {\n    focusManager.setFocused(status === 'active')\n  }\n}\n\nuseEffect(() => {\n  const subscription = AppState.addEventListener('change', onAppStateChange)\n\n  return () => subscription.remove()\n}, [])\n"})}),"\n",(0,t.jsx)(n.h3,{id:"managing-focus-state",children:"Managing Focus State"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { focusManager } from '@tanstack/react-query'\n\n// Override the default focus state\nfocusManager.setFocused(true)\n\n// Fallback to the default focus check\nfocusManager.setFocused(undefined)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"disabling-and-pausing-queries",children:"Disabling and Pausing Queries"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If you ever want to disable a query from running automatically, you can use the ",(0,t.jsx)(n.code,{children:"enabled = false"})," option."]}),"\n",(0,t.jsx)(n.li,{children:"The enabled option can also take a callback as an option."}),"\n",(0,t.jsxs)(n.li,{children:["When enabled is false:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If the query has cached data, then the query will be initialized in the ",(0,t.jsx)(n.code,{children:"status === 'success'"})," or ",(0,t.jsx)(n.code,{children:"isSuccess"})," state."]}),"\n",(0,t.jsxs)(n.li,{children:["If the query does not have cached data, then the query will start in the ",(0,t.jsx)(n.code,{children:"status === 'pending'"})," and ",(0,t.jsx)(n.code,{children:"fetchStatus === 'idle'"})," state."]}),"\n",(0,t.jsx)(n.li,{children:"The query will not automatically fetch on mount."}),"\n",(0,t.jsx)(n.li,{children:"The query will not automatically refetch in the background."}),"\n",(0,t.jsxs)(n.li,{children:["The query will ignore query client ",(0,t.jsx)(n.code,{children:"invalidateQueries"})," and ",(0,t.jsx)(n.code,{children:"refetchQueries"})," calls that would normally result in the query refetching."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"refetch"})," returned from ",(0,t.jsx)(n.code,{children:"useQuery"})," can be used to manually trigger the query to fetch. However, it will not work with ",(0,t.jsx)(n.code,{children:"skipToken"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"function Todos() {\n  const { isLoading, isError, data, error, refetch, isFetching } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n    enabled: false,\n  })\n\n  return (\n    <div>\n      <button onClick={() => refetch()}>Fetch Todos</button>\n\n      {data ? (\n        <>\n          <ul>\n            {data.map((todo) => (\n              <li key={todo.id}>{todo.title}</li>\n            ))}\n          </ul>\n        </>\n      ) : isError ? (\n        <span>Error: {error.message}</span>\n      ) : isLoading ? (\n        <span>Loading...</span>\n      ) : (\n        <span>Not ready ...</span>\n      )}\n\n      <div>{isFetching ? 'Fetching...' : null}</div>\n    </div>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"lazy-queries",children:"Lazy Queries"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The enabled option can be used to permanently disable a query, but it can also enable / disable it at a later time."}),"\n",(0,t.jsx)(n.li,{children:"An example of this would be when you want form to fire off the first request when the user enters a filter value."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"function Todos() {\n  const [filter, setFilter] = React.useState('')\n\n  const { data } = useQuery({\n    queryKey: ['todos', filter],\n    queryFn: () => fetchTodos(filter),\n    // \u2b07\ufe0f disabled as long as the filter is empty\n    enabled: !!filter,\n  })\n\n  return (\n    <div>\n      // \ud83d\ude80 applying the filter will enable and execute the query\n      <FiltersForm onApply={setFilter} />\n      {data && <TodosTable data={data} />}\n    </div>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"isloading-previously-isinitialloading",children:["isLoading (Previously: ",(0,t.jsx)(n.code,{children:"isInitialLoading"}),")"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Lazy queries will have ",(0,t.jsx)(n.code,{children:"status: 'pending'"})," right from the start because there is no data yet. This means that you cannot use this flag to show a loading spinner."]}),"\n",(0,t.jsxs)(n.li,{children:["If you are disabling or using lazy queries, you can use the ",(0,t.jsx)(n.code,{children:"isLoading"})," flag instead."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"isLoading"})," flag is derived from ",(0,t.jsx)(n.code,{children:"isPending && isFetching"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"query-retries",children:"Query Retries"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["When a ",(0,t.jsx)(n.code,{children:"useQuery"})," fails and throws an error, the query will be automatically retried if it has not reached the maximum number of consecutive retries."]}),"\n",(0,t.jsxs)(n.li,{children:["You can configure retries on a global or individual query level.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Setting ",(0,t.jsx)(n.code,{children:"retry = false"})," disables retries."]}),"\n",(0,t.jsxs)(n.li,{children:["Setting ",(0,t.jsx)(n.code,{children:"retry = 6"})," will retry six times before showing the final error thrown by the function."]}),"\n",(0,t.jsxs)(n.li,{children:["Setting ",(0,t.jsx)(n.code,{children:"retry = true"})," will infinitely retry failing requests."]}),"\n",(0,t.jsxs)(n.li,{children:["Setting ",(0,t.jsx)(n.code,{children:"retry = (failureCount, error) => ..."})," allows for custom logic."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useQuery } from '@tanstack/react-query'\n\n// Make a specific query retry a certain number of times\nconst result = useQuery({\n  queryKey: ['todos', 1],\n  queryFn: fetchTodoListPage,\n  retry: 10, // Will retry failed requests 10 times before displaying an error\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"retry-delay",children:"Retry Delay"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"By default, retries in TanStack Query do not happen immediately after a request fails."}),"\n",(0,t.jsxs)(n.li,{children:["The default ",(0,t.jsx)(n.code,{children:"retryDelay"})," is set to double each attempt (starting at ",(0,t.jsx)(n.code,{children:"1000"}),"ms), but doesn't exceed 30 seconds."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"// Configure for all queries\nimport {\n  QueryCache,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n    },\n  },\n})\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"paginated--lagged-queries",children:"Paginated / Lagged Queries"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Paginated data works by including the page information in the query key."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"const result = useQuery({\n  queryKey: ['projects', page],\n  queryFn: fetchProjects,\n})\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If this example is run, you'll notice that the UI jumps in and out."}),"\n",(0,t.jsx)(n.li,{children:"To get around this, TanStack query uses something called PlaceHolder Data."}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"better-paginated-queries-with-placeholderdata",children:["Better Paginated Queries with ",(0,t.jsx)(n.code,{children:"placeholderData"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["By setting ",(0,t.jsx)(n.code,{children:"placeholderData"})," to ",(0,t.jsx)(n.code,{children:"(previousData) => previousData"})," or ",(0,t.jsx)(n.code,{children:"keepPreviousData"})," function exported from TanStack Query, you can do a few new things.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The data from the last fetch will still be available while the new data is being fetched, even though the query key is changed."}),"\n",(0,t.jsx)(n.li,{children:"When the new data arrives, it is seamlessly swapped out with the old data."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"isPlaceholderData"})," is made available to know what data the query is currently providing you."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { keepPreviousData, useQuery } from '@tanstack/react-query'\nimport React from 'react'\n\nfunction Todos() {\n  const [page, setPage] = React.useState(0)\n\n  const fetchProjects = (page = 0) =>\n    fetch('/api/projects?page=' + page).then((res) => res.json())\n\n  const { isPending, isError, error, data, isFetching, isPlaceholderData } =\n    useQuery({\n      queryKey: ['projects', page],\n      queryFn: () => fetchProjects(page),\n      placeholderData: keepPreviousData,\n    })\n\n  return (\n    <div>\n      {isPending ? (\n        <div>Loading...</div>\n      ) : isError ? (\n        <div>Error: {error.message}</div>\n      ) : (\n        <div>\n          {data.projects.map((project) => (\n            <p key={project.id}>{project.name}</p>\n          ))}\n        </div>\n      )}\n      <span>Current Page: {page + 1}</span>\n      <button\n        onClick={() => setPage((old) => Math.max(old - 1, 0))}\n        disabled={page === 0}\n      >\n        Previous Page\n      </button>\n      <button\n        onClick={() => {\n          if (!isPlaceholderData && data.hasMore) {\n            setPage((old) => old + 1)\n          }\n        }}\n        // Disable the Next Page button until we know a next page is available\n        disabled={isPlaceholderData || !data?.hasMore}\n      >\n        Next Page\n      </button>\n      {isFetching ? <span> Loading...</span> : null}\n    </div>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"lagging-infinite-query-results-with-placeholderdata",children:["Lagging Infinite Query results with ",(0,t.jsx)(n.code,{children:"placeholderData"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"placeholderData"})," option also works with ",(0,t.jsx)(n.code,{children:"useInfiniteQuery"})," hook."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"infinite-queries",children:"Infinite Queries"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'Rendering lists that can additively "load more" data onto an existing set or "infinitely scroll" is a common UI pattern.'}),"\n",(0,t.jsxs)(n.li,{children:["In this use case, you can use ",(0,t.jsx)(n.code,{children:"useInfiniteQuery"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["There are a few things different about ",(0,t.jsx)(n.code,{children:"useInfiniteQuery"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data"})," is not an object containing infinite query data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data.pages"})," array contains the fetched pages."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data.pageParams"})," array contains the page params used to fetch the pages."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"fetchNextPage"})," and ",(0,t.jsx)(n.code,{children:"fetchPreviousPage"})," functions are available."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"initialPageParam"})," option is available to specify the initial page param."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"getNextPageParam"})," and ",(0,t.jsx)(n.code,{children:"getPreviousPageParam"})," options are available for determining if there is more data to load and the info to fetch it."]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"hasNextPage"})," boolean is available."]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"hasPreviousPage"})," boolean is available."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"isFetchingNextPage"})," and ",(0,t.jsx)(n.code,{children:"isFetchingPreviousPage"})," booleans are now available."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Example: There is an API that returns pages of 3 projects at a time based on a cursor index."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"fetch('/api/projects?cursor=0')\n// { data: [...], nextCursor: 3}\nfetch('/api/projects?cursor=3')\n// { data: [...], nextCursor: 6}\nfetch('/api/projects?cursor=6')\n// { data: [...], nextCursor: 9}\nfetch('/api/projects?cursor=9')\n// { data: [...] }\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:['In this case, you can make a "Load More" UI by:',"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Waiting for ",(0,t.jsx)(n.code,{children:"useInfiniteQuery"})," to request the first group of data by default."]}),"\n",(0,t.jsxs)(n.li,{children:["Returning the information for the next query in ",(0,t.jsx)(n.code,{children:"getNextPageParam"})]}),"\n",(0,t.jsxs)(n.li,{children:["Calling ",(0,t.jsx)(n.code,{children:"fetchNextPage"})," function"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useInfiniteQuery } from '@tanstack/react-query'\n\nfunction Projects() {\n  const fetchProjects = async ({ pageParam }) => {\n    const res = await fetch('/api/projects?cursor=' + pageParam)\n    return res.json()\n  }\n\n  const {\n    data,\n    error,\n    fetchNextPage,\n    hasNextPage,\n    isFetching,\n    isFetchingNextPage,\n    status,\n  } = useInfiniteQuery({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  })\n\n  return status === 'pending' ? (\n    <p>Loading...</p>\n  ) : status === 'error' ? (\n    <p>Error: {error.message}</p>\n  ) : (\n    <>\n      {data.pages.map((group, i) => (\n        <React.Fragment key={i}>\n          {group.data.map((project) => (\n            <p key={project.id}>{project.name}</p>\n          ))}\n        </React.Fragment>\n      ))}\n      <div>\n        <button\n          onClick={() => fetchNextPage()}\n          disabled={!hasNextPage || isFetchingNextPage}\n        >\n          {isFetchingNextPage\n            ? 'Loading more...'\n            : hasNextPage\n              ? 'Load More'\n              : 'Nothing more to load'}\n        </button>\n      </div>\n      <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>\n    </>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Calling ",(0,t.jsx)(n.code,{children:"fetchNextPage"})," while an ongoing fetch is in progress risks overwritten data happening in the background."]}),"\n",(0,t.jsx)(n.li,{children:"At all times, there can only be a single fetch for an Infinite Query at a time."}),"\n",(0,t.jsxs)(n.li,{children:["If you want to enable simultaneous fetching, you can do ",(0,t.jsx)(n.code,{children:"{ cancelRefetch: false }"})," option within ",(0,t.jsx)(n.code,{children:"fetchNextPage"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"what-happens-when-an-infinite-query-needs-to-be-re-fetched",children:"What happens when an infinite query needs to be re-fetched?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each group is re-fetched sequentially."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"what-if-i-want-to-implement-a-bi-directional-infinite-list",children:"What if I want to implement a bi-directional infinite list?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Bi-Direction infinite lists can be implemented using ",(0,t.jsx)(n.code,{children:"getPreviousPageParam"}),", ",(0,t.jsx)(n.code,{children:"fetchPreviousPage"}),", ",(0,t.jsx)(n.code,{children:"hasPreviousPage"})," and ",(0,t.jsx)(n.code,{children:"isFetchingPreviousPage"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"what-if-i-want-to-show-the-pages-in-reverse-order",children:"What if I want to show the pages in reverse order?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You can use the select option:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  select: (data) => ({\n    pages: [...data.pages].reverse(),\n    pageParams: [...data.pageParams].reverse(),\n  }),\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"what-if-i-want-to-manually-update-the-infinite-query",children:"What if I want to manually update the infinite query?"}),"\n",(0,t.jsx)(n.h4,{id:"manually-removing-first-page",children:"Manually removing first page:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"queryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(1),\n  pageParams: data.pageParams.slice(1),\n}))\n"})}),"\n",(0,t.jsx)(n.h4,{id:"manually-removing-a-single-value-from-an-individual-page",children:"Manually removing a single value from an individual page:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"const newPagesArray =\n  oldPagesArray?.pages.map((page) =>\n    page.filter((val) => val.id !== updatedId),\n  ) ?? []\n\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: newPagesArray,\n  pageParams: data.pageParams,\n}))\n"})}),"\n",(0,t.jsx)(n.h4,{id:"keep-only-the-first-page",children:"Keep only the first page:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"queryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(0, 1),\n  pageParams: data.pageParams.slice(0, 1),\n}))\n"})}),"\n",(0,t.jsx)(n.h3,{id:"what-if-i-want-limit-the-number-of-pages",children:"What if I want limit the number of pages?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["In some cases, you may want to limit the pages stored in query data to improve the performance and UX.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When the user can load a large number of pages (memory usage)"}),"\n",(0,t.jsx)(n.li,{children:"When you have to refetch an infinite query that contains dozens of pages (network usage: all the pages are sequentially fetched)"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:'The solution is to use a "Limited Infinite Query".'}),"\n",(0,t.jsxs)(n.li,{children:["Set the ",(0,t.jsx)(n.code,{children:"maxPages"})," option in conjunction with the ",(0,t.jsx)(n.code,{children:"getNextPageParam"})," and ",(0,t.jsx)(n.code,{children:"getPreviousPageParam"})," to allow fetching pages when needed in both directions."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n  maxPages: 3,\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"what-if-my-api-doesnt-return-a-cursor",children:"What if my API doesn't return a cursor?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["You can use the ",(0,t.jsx)(n.code,{children:"pageParam"})," as a cursor. Because ",(0,t.jsx)(n.code,{children:"getNextPageParam"})," and ",(0,t.jsx)(n.code,{children:"getPreviousPageParam"})," also get the ",(0,t.jsx)(n.code,{children:"pageParam"})," of the current page, you can use it to calculate the next / previous page param."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"return useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, allPages, lastPageParam) => {\n    if (lastPage.length === 0) {\n      return undefined\n    }\n    return lastPageParam + 1\n  },\n  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {\n    if (firstPageParam <= 1) {\n      return undefined\n    }\n    return firstPageParam - 1\n  },\n})\n"})}),"\n",(0,t.jsx)(n.h2,{id:"initial-query-data",children:"Initial Query Data"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["There are many ways to supply initial data for a query to the cache before needing it:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Declaratively: Provide ",(0,t.jsx)(n.code,{children:"initialData"})," to a query to pre-populate it's cache if empty."]}),"\n",(0,t.jsxs)(n.li,{children:["Imperatively:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Prefetch the data using ",(0,t.jsx)(n.code,{children:"queryClient.prefetchQuery"})]}),"\n",(0,t.jsxs)(n.li,{children:["Manually place the data into the cache using ",(0,t.jsx)(n.code,{children:"queryClient.setQueryData"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"using-initialdata-to-pre-populate-a-query",children:["Using ",(0,t.jsx)(n.code,{children:"initialData"})," to pre-populate a query"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When you already have the data prepared in your app, you can provide it directly to the query."}),"\n",(0,t.jsxs)(n.li,{children:["If this is the case, you can use ",(0,t.jsx)(n.code,{children:"config.initialData"})," option to set the initial data for the query and skip the loading state."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"const result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"statetime-and-initialdataupdatedat",children:[(0,t.jsx)(n.code,{children:"stateTime"})," and ",(0,t.jsx)(n.code,{children:"initialDataUpdatedAt"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["By default, ",(0,t.jsx)(n.code,{children:"initialData"})," is treated as totally fresh, as if it was just fetched. This means that it will affect how it is interpreted by the ",(0,t.jsx)(n.code,{children:"staleTime"})," option.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If the query observer is configured with ",(0,t.jsx)(n.code,{children:"initialData"}),", and no ",(0,t.jsx)(n.code,{children:"staleTime"})," (Default 0), the query will immediately refetch when it mounts."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"// Will show initialTodos immediately, but also immediately refetch todos after mount\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If you configure your query observer with ",(0,t.jsx)(n.code,{children:"initialData"})," and a ",(0,t.jsx)(n.code,{children:"staleTime"})," of 1000ms, the data will be considered fresh for that amount of time."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 1000,\n})\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If the ",(0,t.jsx)(n.code,{children:"initialData"})," isn't fresh, use can use the ",(0,t.jsx)(n.code,{children:"initialDataUpdatedAt"})," option. You can pass a numeric Javascript timestamp in ms of when the data was last updated."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 60 * 1000, // 1 minute\n  // This could be 10 seconds ago or 10 minutes ago\n  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"initial-data-function",children:"Initial Data Function"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If the process for accessing a query's initial data is intensive or not something you want to do on every render, you can pass the function as an ",(0,t.jsx)(n.code,{children:"initialData"})," value."]}),"\n",(0,t.jsx)(n.li,{children:"The function will only be executed once when the query is initialized."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"const result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: () => getExpensiveTodos(),\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"initial-data-from-cache",children:"Initial Data from Cache"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You can also provide initial data for a query from the cached result of another. This is great for adding the result of an individual item from a list."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"const result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch('/todos'),\n  initialData: () => {\n    // Use a todo from the 'todos' query as the initial data for this todo query\n    return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)\n  },\n})\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"initial-data-from-the-cache-with-initialdataupdatedat",children:["Initial Data from the cache with ",(0,t.jsx)(n.code,{children:"initialDataUpdatedAt"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Getting initial data from the cache means the source query is likely old."}),"\n",(0,t.jsxs)(n.li,{children:["It is suggested that you pass the source query's ",(0,t.jsx)(n.code,{children:"dataUpdatedAt"})," to ",(0,t.jsx)(n.code,{children:"initialDataUpdatedAt"})," to allow it be re-fetched if needed."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"const result = useQuery({\n  queryKey: ['todos', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () =>\n    queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),\n  initialDataUpdatedAt: () =>\n    queryClient.getQueryState(['todos'])?.dataUpdatedAt,\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"conditional-initial-data-from-cache",children:"Conditional Initial Data from Cache"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the cached source infromation is old, you may not want it at all."}),"\n",(0,t.jsxs)(n.li,{children:["You can use the ",(0,t.jsx)(n.code,{children:"queryClient.getQueryState"})," method instead to get more infromation about the source query, including a ",(0,t.jsx)(n.code,{children:"state.dataUpdatedAt"}),' timstamp you can use to decide if the query is "fresh" enough.']}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"const result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () => {\n    // Get the query state\n    const state = queryClient.getQueryState(['todos'])\n\n    // If the query exists and has data that is no older than 10 seconds...\n    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {\n      // return the individual todo\n      return state.data.find((d) => d.id === todoId)\n    }\n\n    // Otherwise, return undefined and let it fetch from a hard loading state!\n  },\n})\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var s=i(6540);const t={},a=s.createContext(t);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);